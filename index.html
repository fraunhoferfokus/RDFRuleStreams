<!DOCTYPE html>
<html>
	<head>
		<title>Extension of the SPARQL Abstract Data Model for RDF Stream Processing</title>
		<meta charset="utf-8" />
		<script src="http://www.w3.org/Tools/respec/respec-w3c-common" async="async" class="remove"></script>
		<script class="remove">
      var respecConfig = {
          specStatus: "CG-DRAFT",
          shortName:  "rdf-stream-semantics",
          editors: [
            {
              name:       "Editor 1",
              company:    "Company 1",
              companyURL: "http://example1.com/",
              mailto: "ed1@example1.com"
            },
            {
              name:       "Editor 2",
              company:    "Company 2",
              companyURL: "http://example2.com/",
              mailto: "ed2@example1.com"
            }
          ],
          authors: [
            {
              name:       "Tara Athan",
              company:    "Athan Services",
              companyURL: "http://athant.com",
              mailto: "taraathan@gmail.com"
            },
            {
              name:       "Author 2",
              company:    "Company 2",
              companyURL: "http://example2.com/",
              mailto: "auth2@example1.com"
            }
          ],
          wg:           "RDF Stream Processing Community Group",
          wgURI:        "https://www.w3.org/community/rsp/",
          wgPublicList: "public-rsp",

          localBiblio:  {
            "LINEARCOMPOSITION": {
              title: "Multi-device Linear Composition on the Web: Enabling Multi-device Linear Media with HTMLTimingObject and Shared Motion",
              href: "https://sites.google.com/site/mediasynchronization/Paper4_Arntzen_webComposition_CR.pdf?attredirects=0&amp;d=1",
              authors: [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "François Daoust",
                "Dominique Hazaël-Massieux"
              ]
            },
            "BLOGIC": {
              title:    "Blogic",
              href:     "http://www.slideshare.net/PatHayes/blogic-iswc-2009-invited-talk",
              authors:  [
                "Pat Hayes"
              ]
            },
            "DUL": {
              title:    "DOLCE+DnS Ultralite (dul)",
              href:     "http://lov.okfn.org/dataset/lov/vocabs/dul",
              authors:  [
                "Aldo Gangemi"
              ]
            },
            "DVB-CSS": {
              title: "ETSI TS 103 256-2 V1.1.1 Digital Video Broadcasting (DVB); Companion Screens and Streams; Part 2: Content Identification and Media Synchronization",
              href: "http://www.etsi.org/modules/mod_StandardSearch/pdf.png"
            },
            "SHAREDMOTION": {
              title: "Shared Motion",
              href: "http://motioncorporation.com"
            },
            "MEDIASYNC":{
              title: "MediaSync",
              href: "https://github.com/webtiming/mediasync"
            },
            "SEQUENCER" : {
              title: "Open-source sequencer library",
              href: "https://github.com/webtiming/sequencer"
            }
          },
          otherLinks: [
            {
              key: "Version history",
              data: [
                {
                  value: "GitHub streamreasoning/RSP-QL/commits",
                  href: "https://github.com/streamreasoning/RSP-QL/commits/"
                }
              ]
            },
            {
              key: "Participate",
              data: [
                {
                  value: "GitHub streamreasoning/RSP-QL",
                  href: "https://github.com/streamreasoning/RSP-QL"
                },
                {
                  value: "File an issue",
                  href: "https://github.com/streamreasoning/RSP-QL/issues/new"
                },
                {
                  value: "Open issues",
                  href: "https://github.com/streamreasoning/RSP-QL/issues/"
                },
                {
                  value: "Mailing-list (public-rsp@w3.org)",
                  href: "https://lists.w3.org/Archives/Public/public-rsp/"
                }
              ]
            }
          ],

          issueBase: "https://github.com/streamreasoning/RSP-QL/issues/",
          githubAPI: "https://api.github.com/repos/streamreasoning/RSP-QL"
      };
    </script>
		<style type="text/css">
			table{
			    border-collapse: collapse;
			    border-style: hidden hidden none hidden;
			}
			table thead,
			table tbody{
			    border-bottom: solid;
			}
			table td,
			table th{
			    border-left: solid;
			    border-right: solid;
			    border-bottom: solid thin;
			    vertical-align: top;
			    padding: 0.2em;
			}</style>
	</head>
	<body>
		<!-- ABSTRACT -->
		<section id="abstract"> </section>
		<!-- STATUS OF DOCUMENT -->
		<section id="sotd">
			<p> The specification is intended for discussion within the RDF Stream Processing
				Community Group. Its content does not yet represent the consensus of the Community
				Group. </p>
			<p class="warning"> This specification is incomplete. </p>
		</section>
		<section id="tof"></section>
		<!-- INTRODUCTION -->
		<section class="informative" id="intro">
			<h2>Introduction</h2>
			<p>The abstract goal is to provide a data model and the related semantics to describe
				RDF stream processing in terms of operations on hierarchical data structures with
				named versions.</p>
			<p>We first describe model components for associative (named) constructs build on
				existing data structure types, as descibed in Table A, to generalize RDF datasets.
				If the named graphs of RDF datasets are considered statements within a context, then
				the higher-order associative data structures provide a means to handle multi-faceted
				and nested contexts.</p>
			<p>We then develop model components for sequential constructs, to represent temporality
				as well as other linear aspects. A special case of these sequential data structures
				is the versioned data structure, which is similar to the associative data structure,
				but with the extra feature that the outermost names, the version names, are totally
				ordered.</p>
			<p>Thirdly, we introduce specializations of the versioned structures, progressing from
				repositories and stores to data models for RDF streams. </p>
			<p>Finally we describe the semantics of operations on this data model to capture,
				represent, and produce RDF streams. In particular, We accommodates two styles of
				concrete representation:</p>
			<ul>
				<li>A syntactic style that uses reserved words to modify data structures, e.g. by
					casting to different types, extracting substructures or applying window
					operations.</li>
				<li>A semantic style that uses naming conventions within the IRI, e.g. with query
					strings, to indicate such modifications of the data structures.</li>
			</ul>
			<p> In either case, it is necessary that the transformation to the abstract algebra does
				not depend on any details of the IRI; i.e., IRIs are still opaque. However, it is
				acceptable, even typical, that the <em>semantics</em> of the abstract operations
				depend on the datatype of the arguments. </p>
		</section>
		<section id="basics">
			<h2>The Basics</h2>
			<section id="namespaces-and-prefixes">
				<h3>Namespaces and Prefixes</h3>
				<p class="ednote">Do we need any new namespaces for this document? </p>
				<p>Additional prefixes used in this document are the following: </p>
				<div style="text-align: left;">
					<table class="thinborder" style="margin-left: auto; margin-right: auto;">
						<caption id="namespace-table">Table 1: Prefix and Namespaces used in this
							specification</caption>
						<tbody>
							<tr>
								<td><b>prefix</b></td>
								<td><b>namespace IRI</b></td>
								<td><b>definition</b></td>
							</tr>

							<tr>
								<td>rsp</td>
								<td><code>http://www.w3.org/ns/rsp#</code></td>
								<td>The RSP rnamespace</td>
							</tr>

							<tr>
								<td>rdf</td>
								<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
								<td>The RDF namespace [[!RDF-SCHEMA]]</td>
							</tr>

							<tr>
								<td>rdfs</td>
								<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
								<td>The RDFS namespace [[!RDF-SCHEMA]]</td>
							</tr>

							<tr>
								<td>xsd</td>
								<td><code>http://www.w3.org/2000/10/XMLSchema#</code></td>
								<td>XML Schema Namespace [[!XMLSCHEMA11-2]]</td>
							</tr>

							<tr>
								<td>owl</td>
								<td><code>http://www.w3.org/2002/07/owl#</code></td>
								<td>The OWL namespace [[!OWL2-OVERVIEW]]</td>
							</tr>

							<tr>
								<td>owl-time</td>
								<td><code>http://www.w3.org/2006/time#</code></td>
								<td>The OWL-TIME namespace [[!OWL-TIME]]</td>
							</tr>

							<tr>
								<td>prov</td>
								<td><code>http://www.w3.org/ns/prov#</code></td>
								<td>The PROV namespace [[!PROV-DM]]</td>
							</tr>

							<tr>
								<td>dul</td>
								<td><code>http://www.ontologydesignpatterns.org/ont/dul/DUL.owl#</code></td>
								<td>The DOLCE+DnS Ultralet namespace
									(http://lov.okfn.org/dataset/lov/vocabs/dul) [[DUL]]</td>
							</tr>

							<tr>
								<td>(others)</td>
								<td>(various)</td>
								<td>All other namespace prefixes are used in examples only. <br />
									In particular, IRIs starting with "http://example.com"
									represent<br /> some application-dependent IRI [[!IRI]]</td>
							</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section id="constraints">
				<h3>Restrictions on SPARQL Query Language</h3> For simplicity, we use here a subset
				of the SPARQL Query language, with the aim to minimize ambiguity of semantics.
				Constraints are: <ol>
					<li>The Sample aggregation operator is not allowed either explicitly or
						implicitly.</li>
				</ol>
			</section>
		</section>
		<section id="data-structures">
			<h2>Data Structures</h2>
			<p>In this section, we review the data structure types defined in other recommendations
				and state the definitions of new data structure types that support the signature
				definitions of new algebra operators.s</p>
			<section id="overview-datastructuretypes">
				<h3>Overview</h3> This document introduces several new datatypes, including: <ul>
					<li><a>k-th order data structure</a>, k = 0, 1, ...</li>
					<li><a>k-th order associative data structure</a>, k = 0, 1, ...</li>
					<li>k-th order <a>data sequence</a>, k = 0, 1, ...</li>
					<li><a>k-th order associative tree</a>, k = 0, 1, ...</li>
					<li><a>k-th order repository</a>, k = 1, 2, ...</li>
					<li><a>k-th order store</a>, k = 2, 3, ...</li>
					<li>k-th order <a>solitary association</a>, k = 1, 2, ...</li>
				</ul>
				<figure id="datastructure-and-existing-associative-types">
					<img src="datastructure-and-existing-associative-types.svg" alt="" width="400" />
					<figcaption>The top type <a>k-th order data structure</a> may be decomposed into
						three disjoint parts: <a>k-th order associative data structures</a>, <a>k-th
							order data sequences</a>, and <dfn
							data-lt="k-th order RDF multivalent data
								structure|k-th order RDF multivalent data
								structures|multivalent k-th order RDF data
								structure|multivalent k-th order data
								structures|multivalent k-th order data
								structure|multivalent data
								structure|multivalent data
								structures|multivalent structures|multivalent structure"
							>multivalent k-th order RDF data structures</dfn>, (with type symbol
							<dfn data-lt="multivalent">multivalent-structure<sub>k</sub></dfn>, k
						&ge; 0) i.e. those k-th order data structures having both an <a>associative
							part</a> and a <a>sequential part</a>. The existing type of RDF graph is
						subsumed by the <a>associative data structure</a> type, and more
						particularly, is equal to the type of <a>zeroth-order associative trees</a>.
						RDF Datasets are not directly represented in this type system, but are
						emulated by certain associative trees of order 1 or less. The
							<a>repository</a> and <a>store</a> types are subsumed by the
							<a>multivalent data structure</a> type. </figcaption>
				</figure>
			</section>
			<section id="existing-datastructuretypes">
				<h3>Existing Data Structure Types</h3>
				<p class="ednote">For now, I keep this table here as a summary of definitions and
					links to the recommendations for existing datatypes. In the final document, this
					table will be moved to an appendix, or deleted. </p>
				<p>We make use of the following data structure types from other specifications in
					the RDF and SPARQL family:</p>
				<div style="text-align: left;">
					<table class="thinborder" style="margin-left: auto; margin-right: auto;">
						<caption id="existing-data-structure-types-table"><b>Table A</b>: Existing
							data structure types used in this specification</caption>
						<tbody>
							<tr>
								<td><b>Data Structure Type</b></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b>
								</td>
							</tr>
							<tr>
								<td><dfn>solution mapping</dfn></td>
								<td>[[!SPARQL11-Query]] <a
										href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#sparqlSolutions"
										>#sparqlSolutions</a></td>
								<td> partial function μ : V -> RDF-T </td>
							</tr>
							<tr>
								<td><dfn>multiset of solution mappings</dfn></td>
								<td>[[!SPARQL11-Query]] <a
										href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#BasicGraphPattern"
										>#BasicGraphPattern</a></td>
								<td>A multiset is an unordered collection of elements in which each
									element may appear more than once. It is described by a set of
									elements and a cardinality function giving the number of
									occurrences of each element from the set in the multiset. </td>
							</tr>
							<tr>
								<td><dfn>sequence of solution mappings</dfn></td>
								<td>[[!SPARQL11-Query]] <a
										href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#solutionModifiers"
										>#solutionModifiers</a>
								</td>
								<td>The recommendation does not define the concept of "sequence", so
									it is not normatively limited. </td>
							</tr>
							<tr>
								<td><dfn data-lt="RDF triples|triple|triples">RDF triple</dfn></td>
								<td>[[!RDF11-Concepts]] <a
										href="https://www.w3.org/TR/rdf11-concepts/#section-triples"
										>#section-triples</a>
								</td>
								<td>An RDF triple consists of three components: <ul>
										<li>the <dfn id="dfn-subject">subject</dfn>, which is an
												<a><abbr
												title="Internationalized Resource Identifier"
												>IRI</abbr></a> or a <a>blank node</a></li>

										<li>the <dfn id="dfn-predicate">predicate</dfn>, which is an
												<a>IRI</a></li>

										<li>the <dfn id="dfn-object">object</dfn>, which is an
												<a>IRI</a>, a <a>literal</a> or a <a>blank
											node</a></li>
									</ul>
								</td>
							</tr>
							<tr>
								<td><dfn data-lt="RDF Graphs|graph|graphs">RDF Graph</dfn></td>
								<td>[[!RDF11-Concepts]] <a
										href="https://www.w3.org/TR/rdf11-concepts/#section-rdf-graph"
										>#section-rdf-graph</a>
								</td>
								<td>An RDF graph is a set of RDF triples. </td>
							</tr>
							<tr>
								<td><dfn data-lt="RDF Datasets">RDF Dataset</dfn></td>
								<td>[[!RDF11-Concepts]] <a
										href="https://www.w3.org/TR/rdf11-concepts/#section-dataset"
										>#section-dataset</a>
								</td>
								<td>An RDF Dataset is a collection of <a>RDF graphs</a>, and
									comprises: <ul>
										<li>Exactly one <dfn data-lt="default graphs">default
												graph</dfn>, being an <a>RDF graph</a>. The default
											graph does not have a name and MAY be empty.</li>
										<li>Zero or more <dfn data-lt="named graph">named
												graphs</dfn>. Each named graph is a pair consisting
											of an IRI or a blank node (the <dfn>graph name</dfn>),
											and an <a>RDF graph</a>. Graph names are unique within
											an RDF Dataset.</li>
									</ul>
								</td>
							</tr>
							<tr>
								<td><dfn>Graph(</dfn></td>
								<td>[[!SPARQL11-Query]]</td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn>Dataset(</dfn></td>
								<td>[[!SPARQL11-Update]]</td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn>graphNames</dfn></td>
								<td>[[!SPARQL11-Update]]</td>
								<td><b>Definition</b></td>
							</tr>

							<tr>
								<td><dfn>Dataset</dfn></td>
								<td>[[!SPARQL11-Update]]</td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn>Union</dfn></td>
								<td>[[!SPARQL11-Query]]</td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn data-lt="RDF Streams">RDF Stream</dfn></td>
								<td>[[!SPARQL11-Update]]</td>
								<td><b>Definition</b>
								</td>
							</tr>
							<tr>
								<td><dfn data-lt="RDF Names">RDF Name</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b>
								</td>
							</tr>
							<tr>
								<td><dfn data-lt="RDF Surface">RDF Surface (sensu Pat
									Hayes)</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b>
								</td>
							</tr>
							<tr>
								<td><dfn>Graph Store</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn data-lt="IRI|IRIs">Internationalized Resource
										Identifier</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn data-lt="blank nodes">blank node</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn data-lt="literal|literals|RDF Literals">RDF
									Literal</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn data-lt="Update Operations">Update Operation</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b></td>
							</tr>
							<tr>
								<td><dfn data-lt="timestamp predicate">RDF Stream timestamp
										predicate </dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b></td>
							</tr>
						</tbody>
					</table>
				</div>
				<p class="note">In mathematics, the "cardinality" (typically called "multiplicity")
					mapping of multisets is generally assumed to range over non-negative integers.
					The cardinality of a multiset is, typically, defined as the sum of the
					multiplicities of all its elements. </p>
				<p class="ednote">This information may or may not be relevant: Note that not all
					sequences can be converted (by forgetting the order) to multisets with finite
					cardinality; some sequences would correspond to multisets with countable
					cardinality (where cardinality of an element may be a non-negative integer or
					the cardinal number aleph-nought). All multisets with countable cardinality can
					be expressed as sequences. However, not all multisets with countable cardinality
					can be expressed as ordered sequences. SPARQL implicitly assumes sequences of
					solution mappings may be ordered, and hence we may suppose that the intention is
					to use only sequences with finite replication of any value, corresponding to
					multisets with finite cardinality when order is forgotten. </p>
			</section>
			<section id="def-associative">
				<h3>Associative Data Structures</h3>
				<p>The new datatypes introduced in this section, summarized in the following table,
					are associative collections, where the association key is of type <a>RDF
						Name</a>. These datatypes generalize <a>RDF Datasets</a>, which are
					associative collections of <a>RDF Graphs</a>, by allowing the value type (in
					key-value pairs) to be a more complex <a>data structure</a>. </p>
				<div>
					<table>
						<thead data-include="table-head-datatype.html" data-include-sync="true"></thead>
						<tbody data-include="associative-datatype.html" data-include-sync="true"></tbody>
						<tbody data-include="solitary-association-datatype.html"
							data-include-sync="true"></tbody>
					</table>
				</div>
				<p>The new operators introduced in this section are summarized in the following
					table.</p>
				<div>
					<table>
						<thead data-include="table-head-syntax.html" data-include-sync="true"></thead>
						<tbody data-include="associative-syntax.html" data-include-replace="true"
							data-include-sync="true"></tbody>
						<tbody data-include="solitary-syntax.html" data-include-replace="true"
							data-include-sync="true"></tbody>
					</table>
				</div>
				<section id="def-rdf-dataset">
					<h4>RDF Dataset</h4>
					<p>Recall that an <a>RDF Dataset</a> is a collection of <a>RDF graphs</a>, and
						comprises:</p>
					<ul>
						<li>Exactly one <a>default graph</a>.</li>
						<li>Zero or more <a>named graphs</a>.</li>
					</ul>
					<p>We generalize this concept below to accommodate more complex structures.</p>
				</section>
				<section id="def-k-th-order-associative-data-structure">
					<h4>k-th Order Associative RDF Data Structures</h4>
					<p>A <dfn
							data-lt="k-th order associative RDF data structures|k-th order associative data structure|k-th order associative data structures|associative data structure|associative data structures"
							>k-th order associative RDF data structure</dfn> (with type symbol <dfn
							data-lt="associative">associative<sub>k</sub></dfn>, k &ge; 0) is a
							<a>k-th order data structure</a> that is defined inductively as
						follows.</p>
					<ul>
						<li>A <dfn>zeroth-order associative data structure</dfn> (with type symbol
									<dfn>associative<sub>0</sub></dfn>) is an RDF Graph. </li>
						<li>A k-th order associative data structure, k &ge; 1, is specified by the
							tuple [k, N, DSTM] where N is a non-empty subset of <a>RDF Name</a>, and
							DSTM is a mapping from N &cup; {DEFAULT} to <a>data structures</a> of
							order k-1 or less. </li>
					</ul>
					<p>The type symbol for associative structures of order k or less is
								<dfn>associative<sub>&le; k</sub></dfn></p>
					<p><dfn>DEFAULT</dfn> is a reserved name used to streamline the definitions.</p>
					<p>We denote by <dfn data-lt="Associative-NEW"
						>Associative-NEW<sub>k</sub></dfn>(N, DSTM), k &gt; 0, the associative data
						structure specified by the tuple [k, N, DSTM]. </p>
					<p>Further, let G be an RDF Graph, N= {}, and DSTM= {<a>DEFAULT</a>=>G}). We
						define <dfn>Associative-NEW<sub>0</sub></dfn>(N, DSTM) = G.</p>
					<p class="note">The functions <a>Associative-NEW<sub>k</sub></a>, k &ge; 0, thus
						acts as constructors for <a>associative data structures</a>. The constraints
						are that <a>cardinality</a>(N) &gt; 0 if k &gt;0 and <a>cardinality</a>(N)=0
						if k = 0, while DSTM:(N &cup; {<a>DEFAULT</a>}) => structure<sub>&le;
							k-1</sub> if k&gt; 0 while DSTM:{<a>DEFAULT</a>} => RDF Graph if
						k=0.</p>
					<p><dfn data-lt="TypeAssoc">TypeAssoc<sub>k</sub></dfn>(X) is a type constructor
						for k-th order associative structures whose values (in key-value pairs) are
						of type X.</p>
					<p>The order of an <a>associative data structure</a> ADST =
							<a>Associative-NEW</a><sub>k</sub>(N, DSTM) is denoted
						<dfn>order</dfn>(ADST) and has value <a>order</a>(ADST) = k.</p>
					<p>The set of non-reserved names of an <a>associative data structure</a> ADST =
							<a>Associative-NEW</a><sub>k</sub>(N, DSTM) is denoted
						<dfn>names</dfn>(ADST) and has value <a>names</a>(ADST) = N.</p>
					<p>The name mapping of an <a>associative data structure</a> ADST =
							<a>Associative-NEW</a><sub>k</sub>(N, DSTM) is denoted
							<dfn>nameMap</dfn>(ADST) and has value <a>nameMap</a>(ADST) = DSTM.</p>
					<p>A number of convenience functions on <a>associative data structures</a> may
						be defined in terms of the basic functions <a>order</a>, <a>names</a>, and
							<a>nameMap</a>, and the constructor
						<a>Associative-NEW<sub>k</sub></a>.</p>
					<p>We use the following notation.</p>
					<ul>
						<li><dfn>dom</dfn>(M) is the domain of a mapping M.</li>
						<li><dfn>codom</dfn>(M) = {M(n) | n &in; <a>dom</a>(M)} is the codomain of
							mapping M.</li>
						<li>M|<sub>S</sub> = {n => M(n) | n &in; S} denotes the <dfn>restriction of
								a mapping</dfn> M to a set S &sube; <a>dom</a>(M). </li>
						<li>M|<sub> -S</sub> = {n => M(n) | n &in; <a>dom</a>(M) - S} denotes the
							restriction of a mapping M to the complement of set S. </li>
						<li>A mapping is treated as set of key-value pairs, so the usual set
							operations, e.g union ( &cup; ), intersection ( &cap; ), and diff ( - ),
							can be applied to mappings.</li>
						<li>The cardinality of a set is the value of the function
								<dfn>cardinality</dfn>.</li>
					</ul>
					<p>The <dfn>default part</dfn> of an <a>associative data structure</a> ADST =
							<a>Associative-NEW</a><sub>k</sub>(N, DSTM), k &ge; 0, is a <a>data
							structure</a> of <a>order</a> max(0, k-1) or less, is denoted
							<dfn>defaultPart</dfn>(ADST), and has value DSTM(<a>DEFAULT</a>). In
						terms of the basic functions,</p>
					<p>
						<a>defaultPart</a>(ADST) = <a>nameMap</a>(ADST)(<a>DEFAULT</a>).</p>
					<p class="note">The default part of a <a>zeroth-order associative data
							structure</a> is itself; <a>defaultPart</a>(ADST) = ADST. </p>
					<p>A <dfn>solitary association</dfn> (with type symbol <dfn
							data-lt="solitary-association">solitary-association<sub>k</sub></dfn>)
						is an <a>associative data structure</a> where its set of nonreserved names
						contains exactly one name and the default part is empty. That is,
							<a>cardinality</a>(<a>names</a>(SO)) = 1 and <a>defaultPart</a>(SO) =
						{}.</p>
					<aside class="example"><p>The constructor <a>Associative-NEW<sub>k</sub></a>, k
							&gt; 0, can be used to create a <a>solitary association</a> as
							follows.</p>
						<p>Let DST be <a>data structure</a> of order k-1 or less, and let SO =
								Associative-NEW<sub>k</sub>({n}, {n => DST, <a>DEFAULT</a> => {} }).
							Then <a>order</a>(SO) = k, <a>names</a>(SO) = {n}, and
								<a>defaultPart</a>(SO) = {}. Therefore by definition, SO is a
								<a>solitary association</a>.</p>
					</aside>
					<p>We define a specialized constructor for solitary associations,</p>
					<p><dfn data-lt="Solitary-NEW">Solitary-NEW<sub>k</sub></dfn>(n, DST) =
								<a>Associative-NEW<sub>k</sub></a>({n}, {n => DST, <a>DEFAULT</a> =>
						{} }), k &gt; 0 where <a>order</a>(DST) &lt; k.</p>
					<p>The <dfn>named part</dfn> of a k-th order <a>associative data structure</a>
						ADST of order k &ge; 1, denoted <dfn>namedPart</dfn>(ADST), is the <a>k-th
							order associative data structure</a> given by
								<a>Associative-NEW<sub>k</sub></a>(N, DSTM') where N =
						<a>names</a>(ADST), DSTM = <a>nameMap</a>(ADST), and DSTM'(n) = DSTM(n)
						whenever n &in; N, and DSTM'(<a>DEFAULT</a>)={}. In terms of the basic
						functions, </p>
					<p><a>namedPart</a>(ADST) =
							<a>Associative-NEW</a><sub><a>order</a>(ADST)</sub>(<a>names</a>(ADST),
							<a>nameMap</a>(ADST)|<sub><a>names</a>(ADST)</sub> &cup; {<a>DEFAULT</a>
						=> {} })</p>
					<aside class="example"><p>An RDF Graph is the only <a>associative data
								structure</a> that has no named part, i.e. <a>namedPart</a> is
							undefined.</p></aside>
					<aside class="example"><p>A <a>solitary association</a> SO =
								Associative-NEW<sub>k</sub>({n}, {n => DST, <a>DEFAULT</a> => {} }
							is equal to its named part.</p>
						<p>SO = <a>namedPart</a>(SO)</p>
					</aside>
					<p>Let ADST = <a>Associative-NEW<sub>k</sub></a>(N, DSTM) be an <a>associative
							data structure</a> and E be an arbitrary entity. </p>
					<ul>
						<li><dfn>isAssociative</dfn>(E) is true if E is a <a>associative data
								structure</a>; otherwise it is false.</li>
						<li><dfn>isSolitary</dfn>(ADST) is true if ADST is a <a>solitary
								association</a>. </li>
						<li>If <a>isSolitary</a>(ADST) is true, then <dfn>name</dfn>(ADST) is the
							one element of <a>names</a>(ADST). That is, <a>names</a>(ADST) =
								{<a>name</a>(ADST)}</li>
						<li>For every name n, we define the <dfn data-lt="contents|content">content
								for n</dfn> in an <a>associative data structure</a> ADST, denoted
								<dfn>content(n, ADST)</dfn>, as follows. <ul>
								<li>If n is a member of <a>names</a>(ADST), then <a>content</a>(n,
									ADST) = <a>nameMap</a>(ADST)(n);</li>
								<li><a>content</a>(<a>DEFAULT</a>, ADST) =
									<a>defaultPart</a>(ADST);</li>
								<li>otherwise, <a>content</a>(n, ADST) it is defined as the empty
									set.</li>
							</ul>
						</li>
						<li>If <a>isSolitary</a>(ADST) is true, then we define
								<dfn>content(ADST)</dfn> = <a>content</a>( <a>name</a>(ADST),
							ADST).</li>
					</ul>
					<aside>The concrete syntax for building an associative data structure depends on
						the extension of <a>Update Operations</a>, e.g. the <a>OpInsertData</a>
						Update Operation, and the extension of the <a>pattern</a> syntax to express
							<a>k-th order patterns</a>, including k-th order "solitary-association"
						patterns.</aside>
				</section>
			</section>
			<section id="def-data-sequences-structures">
				<h3>RDF Data Sequences and Structures</h3>
				<p>The new datatypes introduced in this section, summarized in the following table,
					are collections that may have a part that is an <a>associative data
						structure</a>, and may also have a part that has a sequential nature.</p>
				<div>
					<table>
						<thead data-include="table-head-datatype.html" data-include-sync="true"></thead>
						<tbody data-include="sequence-datatype.html" data-include-sync="true"></tbody>
						<tbody data-include="structure-datatype.html" data-include-sync="true"
						></tbody>
					</table>
				</div>
				<p>The new operators introduced in this section are summarized in the following
					table.</p>
				<div>
					<table>
						<thead data-include="table-head-syntax.html" data-include-sync="true"></thead>
						<tbody data-include="sequence-syntax.html" data-include-replace="true"
							data-include-sync="true"></tbody>
						<tbody data-include="structure-syntax.html" data-include-replace="true"
							data-include-sync="true"></tbody>
					</table>
				</div>
				<section id="def-data-sequences">
					<h4>RDF Data Sequences</h4>
					<p>An <dfn data-lt="RDF Data Sequences|Data Sequence|Data Sequences">RDF Data
							Sequence</dfn> (with type symbol <dfn>data-sequence</dfn>) is a
							<a>sequence</a> of <a>data structures</a>.</p>
					<p>In this document, we use the term <dfn data-lt="sequences">sequence</dfn> in
						the sense of a totally-ordered set (in mathematics, called a chain) that can
						be strictly monotonically mapped onto the integers. I.e., it is isomorphic,
						as a poset, to a subset of the integers. A sequence may be finite, or
						infinite. If infinite, the set MAY or MAY NOT have a least element, and MAY
						or MAY NOT have a greatest element. If a sequence has neither least nor
						greatest element, then it is said to be <dfn>bi-infinite</dfn>.</p>
					<p>We define a number of syntactic operations on <a>sequences</a> as follows.
						Let SQ be a <a>sequence</a>. </p>
					<ul>
						<li><dfn>isSequence</dfn>(E) is true if E is a <a>sequence</a>; otherwise it
							is false.</li>
						<li>If SQ is a sequence of type X and E is an arbitrary entity of type X,
							then <dfn>isMemberOf</dfn>(E, SQ) is true; otherwise, it is false.</li>
						<li>If SQ is a <a>sequence</a> of type X, then <dfn>members</dfn>(SQ) is the
							set of elements of SQ. </li>
						<li>If E and E' are two elements of SQ, then <dfn>previousTo</dfn>(E, E';
							SQ) is defined; otherwise it is undefined. It has the value true if E
							&lt; E' in the context of SQ, and has the value false if E &gt;= E' in
							the context of SQ. </li>
						<li>If <a>previousTo</a>(E, E'; SQ) is defined, then <dfn>follows</dfn>(E,
							E'; SQ) is defined; otherwise it is undefined. It has the value true if
							E &gt; E' in the context of SQ, and has the value false if E &lt;= E' in
							the context of SQ. </li>
						<li>If SQ has a least element then <dfn>hasLeast</dfn>(SQ) has the value
							true, and otherwise false </li>
						<li>If SQ has a greatest element then <dfn>hasGreatest</dfn>(SQ) has the
							value true, and otherwise false. </li>
						<li>If <a>hasLeast</a>(SQ) is true, then <dfn>least</dfn>(SQ) is defined,
							and has the value of the least element of SQ. Otherwise it is undefined. </li>
						<li>If <a>hasGreatest</a>(SQ) is true, then <dfn>greatest</dfn>(SQ) is
							defined, and has the value of the greatest element of SQ. Otherwise it
							is undefined. </li>
						<li>If <a>least</a>(SQ) = E, then <dfn>isLeastOf</dfn>(E, SQ) has value
							true, and otherwise false. </li>
						<li>Let SQ is a sequence of type X and be E is an arbitrary entity of type
							X. If <a>greatest</a>(SQ) = E, then <dfn>isGreatestOf</dfn>(E, SQ) has
							value true, and otherwise false. </li>
						<li>If <a>isLeastOf</a>(E, DSG) is false, then <dfn>predecessor</dfn>(E; SQ)
							is defined, and has the value of the unique <a>predecessor</a> of E in
							the context of SQ. I.e., if <a>predecessor</a>(E; SQ) = E', then (in the
							context of SQ) E' &lt; E, and for any E'' where E'' &lt; E, it holds
							that E'' &lt;= E'. </li>
						<li>If <a>isGreatestOf</a>(E, SQ) is false, then <dfn>successor</dfn>(E; SQ)
							is defined, and has the value of the unique <a>successor</a> of E in the
							context of SQ. I.e., if <a>successor</a>(E; SQ) = E', then (in the
							context of SQ) E' &gt; E, and for any E'' where E'' &gt; E, it holds
							that E'' &gt;= E'. </li>
						<li>The basic constructor operation <dfn>Cons</dfn> builds sequences by
							adding an additional element to a sequence with a greatest element. The
							basic operation analagous to a "head" function is <a>greatest</a>, that
							returns the greatest element if it exists. We define also the basic
							operation <dfn>exceptGreatest</dfn>, which is the counterpart to the
							traditional "tail" function. </li>
						<li>Square brackets are used in the abstract syntax to define a sequence
							explicitly, with the greatest element first. </li>
						<li>General sequences, including sequences that are not finite, are
							indicated using square brackets around an element containing an index
							variable, with a subscript on the bracket indicating the ordered set the
							index ranges over. For example [i<sup>2</sup>]<sub>i &in; Nat</sub> is
							the semi-infinite sequence of squares of positive numbers, ordered by
							magnitude. For convenience, a constructor function for such sequences is
							defined as follows.</li>
						<li><dfn>Seq-NEW</dfn>(Index, M) = [ M(i) ]<sub>i &in; Index</sub> where
							Index = [Key, &le;<sub>Key</sub>] is a totally-ordered set isomorphic to
							an interval of the integers. The values of various functions on a data
							sequence created using this constructor can be derived using commutation
							from the values of the corresonding functions on the index. E.g., if i
							&in; Index and E = M(i), then <a>successor</a>(E; Seq-NEW(Index, M)) =
							M( <a>successor</a>(i; Index)). </li>
						<li><dfn>TypeSeq</dfn>(X) is a type constructor for sequences whose elements
							are of type X, including empty, finite, semi-infinite, and bi-infinite
							sequences </li>
						<li>Similarly, <dfn>TypeSeq<sup>+</sup></dfn>(X) is a type constructor for
							non-empty sequences whose elements are of type X. </li>
					</ul>
					<p class="ednote">The naming convention "Type..." is used for type constructors.
						This is distinct from the naming convention for object constructors, which
						is "...-NEW".</p>
					<!--
						<li>To iterate over general sequences, let <dfn>next</dfn>(i; Index) have
							the value of the next greater element of the totally-ordered set Index,
							provided i &in; Index and i is not the greatest element of Index. </li>
						<li>If SQ = <a>Seq-NEW</a>(Index, M), we define <dfn>next(i; SQ)</dfn> =
								SQ(<a>next</a>(i; Index)).</li>
						<li>The function <dfn>index</dfn>(SQ) returns an index for the constructed
							sequence that is compatible with the corresponding mapping
								<dfn>indexMap</dfn>(SQ)). However, this function is not
							deterministic.</li>
					</ul>
					<p class="ednote">There is a non-determinism issue regarding <a>index</a> and
							<a>indexMap</a>.</p>
-->
					<aside class="example"> Let DSQ be a <a>data-sequence</a>. In the case that
							<a>hasGreatest</a>(DSQ) is true, then <p>
							<a>Cons</a>( <a>greatest</a>(DSQ), <a>exceptGreatest</a>(DSQ) ) =
							DSQ.</p>
					</aside>
					<aside> The empty sequence, [], is also denoted
						<dfn>SQ<sub>0</sub></dfn>.</aside>
					<aside class="example"><p>For any data structure DST,</p>
						<p><a>Cons</a>(DST, <a>SQ<sub>0</sub></a>) = [DST]</p></aside>
					<aside>A Graph Store in the sense of [[!SPARQL11-Update]] is most closely
						related, of the <a>data structures</a> considered in this document, to a
							<a>data sequence</a> where each element is an <a>associative tree</a> of
						first order or less. </aside>
					<p>In the spirit of [[!SPARQL11-Update]], we define the <dfn>Revise</dfn>
						operation as an explicit operation acting on a <dfn>terminated data
							sequence</dfn> (i.e a <a>data sequence</a> where <a>hasGreatest</a> is
						true) that applies a binary function to the greatest element of the
						sequence, and to the sequence itself, and <a>Cons</a>es the result onto the
						sequence.</p>
					<p>The semantics of <a>Revise</a> are as follows.</p>
					<p><a>Revise</a>(DSQ, BPM) = <a>Cons</a>( BPM(<a>greatest</a>(DSQ), DSQ),
						DSQ)</p>
					<aside class="example">Consider a Graph Store which has been newly initialized
						as the empty graph <p>GS = <a>Cons</a>({}, <a>SQ<sub>0</sub></a>)</p>
						<p>The application of <a>Revise</a> to this graph store with an OpInsertData
							operation specification as a lambda expression is expressed as follows. </p>
						<p>GS' = <a>Revise</a>(GS, (λxy.<a>OpInsertData</a>(P, {}, x, y)) ) <br /> =
								<a>Cons</a>(<a>OpInsertData</a>(P, {}, <a>greatest</a>(GS), GS), GS)
							<br /> where P is a ground Quadpattern (i.e. Quaddata).</p>
						<p>An additional update to this graph store to insert data according to
							another ground quadpattern P' would be expressed as follows.</p>
						<p>GS'' = <a>Revise</a>(GS', (λxy.<a>OpInsertData</a>(P', {}, x, y)) )
							<br /> = <a>Cons</a>(<a>OpInsertData</a>(P', {}, <a>greatest</a>(GS'),
							GS'), GS').</p>
						<p>Note that by the definition of <a>OpInsertData</a> in
							[[!SPARQL11-Update]], any blank node appearing in P' that also appears
							in P must be renamed.</p>
						<p class="ednote">There is a need for a similar operator that does not
							perform renaming, for those cases where the data being inserted is
							consider to lie on the same <a>RDF Surface</a> as the structure it is
							being inserted into. This need should be address in
							[[!SPARQL11-Update]], rather than this document.</p>
					</aside>
					<p class="ednote">Add to table of structural inferences: rdfsq:isMemberOf,
						rdfsq:previousTo, rdfsq:follows, rdfsq:hasLeast, rdfsq:hasGreatest,
						rdfsq:least, rdfsq:greatest, rdfsq:isLeastOf, rdfsq:isGreatestOf,
						rdfsq:predecessor, rdfsq:successor, These relationships can be inferred, but
						only within the context of a particular sequence. The order is not an
						inherent relationship between the two data structures. That means that if
						this information is materialized, it must be done, in a number of cases, as
						a quad, to indicate the context in which it holds. The graph name in the
						quad may or may not "denote" the sequence, depending on the semantics that
						is in play. The sequence does not need to be named explicitly, but can be
						indicated by a blank node, (again, provided that makes sense within the
						active semantics). If the sequence is a named sequence, then whether it is
						appropriate to use that name to materialize such statements depends on the
						active semantics.</p>
					<p>We define a type symbol <dfn>data-sequence<sub>k</sub></dfn> for <a>data
							sequences</a> where the maximum order of the elements is k. Similarly,
								<dfn>data-sequence<sub>&le; k</sub></dfn> is the type of <a>data
							sequences</a> whose elements are k or less, and
								<dfn>data-sequence<sub>fin</sub></dfn> is the type of <a>data
							sequences</a> whose elements have bounded order.</p>
				</section>
				<section id="def-k-th-order-data-structure">
					<h4>k-th Order RDF Data Structure</h4>
					<p>A <dfn
							data-lt="k-th Order RDF Data Structures|k-th Order Data Structure|k-th Order Data Structures|Data Structure|Data Structures"
							>k-th Order RDF Data Structure</dfn> (with type symbol
								<dfn>structure<sub>k</sub></dfn>, k &ge; 0) is defined by cases as
						follows. </p>
					<p>A k-th order RDF data structure DST is a collection of k-th order associative
						data structures </p>
					<ul>
						<li>The optional <dfn>associative part</dfn> of DST is a k-th order
							associative data structure.</li>
						<li>The <dfn>sequential part</dfn> of DST, which is optional if DST has a
							associative part, is a sequence of k-th order associative data
							structures.</li>
					</ul>
					<p>We define a number of syntactic operations on <a>data structures</a> as
						follows. Let DST be a <a>data structure</a>. </p>
					<ul>
						<li><dfn>isDataStructure</dfn>(E) is true if E is a <a>data structure</a>;
							otherwise it is false.</li>
						<li><dfn>hasAssociative</dfn>(DST) is true if DST has a associative part;
							otherwise, it is false.</li>
						<li><dfn>hasSequential</dfn>(DST) is true if DST has a sequential part;
							otherwise, it is false.</li>
						<li><dfn>associativePart</dfn>(DST) is defined on all data structures that
							have a associative part (<a>hasAssociative</a>(DST) is true); otherwise
							it is undefined. When defined, its value is the associative part of
							DST.</li>
						<li><dfn>sequentialPart</dfn>(DST) is defined on all data structures that
							have a sequential part (<a>hasSequential</a>(DST) is true); otherwise it
							is undefined. When defined, its value is the data sequence that is the
							sequential part of DST.</li>
					</ul>
					<p class="note">If a k-th order <a>data structure</a> ADST has no sequential
						part, then it is itself its associative part (<a>associativePart</a>(ADST) =
						ADST). In that case it is a k-th order <a>associative data structure</a>,
						e.g. an RDF graph (k=0) or k-th order <a>associative tree</a>.</p>
					<p class="note">If a k-th order data structure DSQ does not have an associative
						part, then <a>sequentialPart</a>(DSQ) = DSQ; in this case, the data
						structure is a <a>data sequence</a>. In particular, it is a sequence of k-th
						order <a>associative data structures</a>. We define this special case of
							<a>data sequence</a> to be a <dfn data-lt="k-th order data sequences"
							>k-th order data sequence</dfn>.</p>
					<p>We extend the functions defined earlier on associative data structures to
						data structures where <a>hasAssociative</a> is true according to the
						following example: <a>names</a>(DST) =
						<a>names</a>(<a>associativePart</a>(DST)), and so on.</p>
					<p>The type consisting of all data structure of order k or less is given the
						type symbol <dfn>structure<sub>&le; k</sub></dfn>, k &ge; 0, while the type
						of all data structure with finite order has the type symbol
								<dfn>structure<sub>fin</sub></dfn>.</p>
				</section>
			</section>
			<section id="def-kth-order-associative tree">
				<h3>k-th Order RDF Associative Tree</h3>
				<p>The new operators introduced in this section are summarized in the following
					table.</p>
				<table>
					<thead data-include="table-head-syntax.html" data-include-sync="true"></thead>
					<tbody data-include="tree-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
				</table>
				<p class="ednote">perhaps use "Stream RDF dataset" "RDF stream dataset" "RDF dataset
					structure" or similar for these classes? <br /> If we take our way of emulating
					RDF Streams and make it a type, then we could call it an RDF Stream Store.</p>
				<p>A <dfn
						data-lt="k-th Order RDF Associative Trees|k-th Order Associative Tree|k-th Order Associative Trees|Associative Tree|Associative Trees"
						>k-th Order RDF Associative Tree</dfn> (with type symbol <dfn
						data-lt="associative-tree|associative-trees"
						>associative-tree<sub>k</sub></dfn>) is a <a>k-th order associative data
						structure</a> AT with the following properties. </p>
				<ul>
					<li><a>defaultPart</a>(AT) is an <a>associative tree</a> of order j or less,
						where j = max(0,<a>order</a>(AT)-1).</li>
					<li>For every n in <a>names</a>(AT), <a>content</a>(n, AT) is an <a>associative
							tree</a> of order k-1 or less.</li>
				</ul>
				<p class="note">If ADST = <a>Associative-NEW<sub>k</sub></a>(N, DSTM), then ADST is
					an associative tree iff k=0 and <a>codom</a>(DSTM) &sub;
						associative-tree<sub>0</sub> or <a>codom</a>(DSTM) &sub;
						associative-tree<sub>&le; k-1</sub></p>
				<p class="note">Every RDF Graph is a <dfn data-lt="zeroth-order associative trees"
						>zeroth-order associative tree</dfn>, and every zeroth-order associative
					tree is an RDF Graph.</p>
				<p>A <dfn>k-th order solitary-association-tree</dfn> (with type symbol <dfn
						data-lt="solitary-association-tree|solitary-association-trees"
							>solitary-association-tree<sub>k</sub></dfn>) is a k-th order
						<a>associative tree</a> that is also a <a>solitary association</a>.</p>
				<p class="example">A named graph may be emulated as a first-order
						<a>solitary-association-tree</a>.</p>
				<p class="note"> Hereafter in this document, <a>solitary-association-tree</a>,
					without qualification, means a <a>k-th order solitary-association-tree</a> where
					k is not specified. </p>
				<p class="example">An RDF Dataset, as defined in [[!RDF-Concepts]] may be emulated
					as an <a>associative tree</a> of order 1 or less. An RDF Dataset always has a
					default part, its default graph, which may be the empty graph. If the RDF
					Dataset contains at least one named graph, then the corresponding <a>associative
						tree</a> has a named part and so is a first-order <a>associative
					tree</a>.</p>
				<p class="ednote">To be clarified in a separate semantics section: just as there is
					not a single recommended semantics for RDF Datasets, it is important to be
					inclusive regarding possible semantics for k-th order associative trees. An
					important consideration is whether the components of the tree lie on a single
						<a>RDF Surface (sensu Pat Hayes)</a>, i.e. do they share blank nodes. </p>
				<p>We define syntactic operations on <a>associative trees</a> as follows. Let E be
					an arbitrary entity. </p>
				<ul>
					<li><dfn>isTree</dfn>(E) is true if E is an <a>associative tree</a>; otherwise
						it is false.</li>
				</ul>
				<p class="note">The constructor <a>Associative-NEW<sub>k</sub></a> defined for
					general <a>associative data structures</a> works as well for <a>associative
						trees</a> of arbitrary order.</p>
				<p>If N is a set of names and AT is a <a>k-th order associative tree</a>, then
						<dfn>content-UNION</dfn>(N, AT) is defined as
						<a>Tree-UNION</a>({<a>content</a>(n, AT)|n is in N}) .</p>
				<p class="ednote">All these functions need to be added to the table of structural
					inferences.</p>
				<p class="ednote">A <dfn data-lt="timestamped graphs">timestamped graph</dfn> is
					defined in @@@<a href="">RDF Stream Abstract Syntax and Semantics</a> as an RDF
					Dataset with one named graph and a distinguished triple, the timestamp triple,
					in its default graph having the name of the named graph as its subject. A
					timestamped graph may be emulated by a associative tree of second order or less,
					as described in Section <a href="#def-rdf-stream-as-second-order-store"></a></p>
			</section>
			<section id="def-versioned-repository">
				<h3>RDF Versioned Structures and Repositories</h3>
				<p>The new operators introduced in this section are summarized in the following
					table.</p>
				<table>
					<thead data-include="table-head-syntax.html" data-include-sync="true"></thead>
					<tbody data-include="versioned-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="repository-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
				</table>
				<section id="def-kth-order-rdf-versioned">
					<h4>k-th Order Versioned RDF Data structures</h4>
					<p>A <dfn
							data-lt="k-th Order Versioned RDF Data Structures|k-th Order Versioned Data Structure|k-th Order Versioned Data Structures|Versioned RDF Data Structure|Versioned RDF Data Structures|Versioned Data Structure|Versioned Data Structures"
							>k-th Order Versioned RDF Data Structure</dfn> VDST is a <a>k-th order
							RDF multivalent data structure</a> that meets the following
						requirements. </p>
					<ul>
						<li>Let DSQ = <a>sequentialPart</a>(VDST).</li>
						<li>Each element DST of DSQ is a <a>solitary association</a>. These elements
							are called <dfn>versions</dfn> of the versioned structure.</li>
						<li>The names of the sequence elements are unique. I.e., if DST &ne; DST'
							are both members of DSQ, then <a>name</a>(DSQ) = <a>name</a>(DSQ') iff
							DSQ = DSQ'. The names are called the <dfn>version names</dfn> of the
							structure and they form an ordered set, with the order consistent with
							the sequence order.</li>
						<li>If DST' = <a>successor</a>(DST; DSQ), then <a>content</a>(DST') &ne;
								<a>content</a>(DST). That is, the content of adjacent versions is
							distinct.</li>
					</ul>
					<p class="note">The sequence corresponds to a mapping from the <a>version
							names</a> to the contents of the <a>versions</a>. Further, the contents
						of adjacent versions are distinct; this means each step in the sequence
						corresponds to a non-vacuous <i>revision</i> of a <a>data structure</a> of
						order k-1 or less.</p>
					<p>Let VDST be a <a>k-th order versioned data structure</a>.</p>
					<p>Each element of the sequential part of VDST is called a <dfn>version</dfn> of
						VDST. The function <dfn>isVersionOf</dfn>(U, VDST) is defined for all
						entities U, and is true exactly when <a>isMemberOf</a>(U,
							<a>sequentialPart</a>(VDST)) is true. </p>
					<p class="ednote">As written, a <a>version</a> is a solitary association. It may
						seem more intuitive to refer to the content of that solitary association as
						the version. However, it is quite possible for two (non-adjacent) versions
						to have the same content (i.e. a rollback). If we used only the content as
						the version, then it would not be clear which of these versions we were
						referring to.</p>
					<p>We say a version U is a <dfn>previous version</dfn> of version V in the
						context of VDST if <a>previousTo</a>(U, V; <a>sequentialPart</a>(VDST)) is
						true, and similarly V is called a <dfn>following version</dfn> of U in the
						context of the versioned structure. The function
							<dfn>isPreviousVersionTo</dfn>(U, V; VDST) is defined whenever U and V
						are versions of VDST (<a>isVersionOf</a>(U, VDST) = <a>isVersionOf</a>(V,
						VDST) = true), and has the value <a>previousTo</a>(U, V;
							<a>sequentialPart</a>(VDST)); otherwise, it is undefined.</p>
					<p>An <dfn>initial version</dfn> of a versioned structure is a version that does
						not have a previous version. A versioned structure MAY have an initial
						version.</p>
					<p> The function <dfn>hasInitialVersion</dfn>(VDST) is defined and has the value
						of <a>hasLeast</a>(<a>sequentialPart</a>(VDST)). </p>
					<p class="note">If the sequential part of a versioned structure has an initial
						version, then it is unique, due to the order being total; further, it is a
						minimal element of the sequential part. </p>
					<p>If VDST has an initial version, then the function
						<dfn>initialVersionOf</dfn>(VDST) =
						<a>least</a>(<a>sequentialPart</a>(VDST)) is defined.</p>
					<p>If V is a version of VDST that is not an initial version, then we define the
							<dfn>preceding version</dfn> of V in the context of VDST to be the
							<a>predecessor</a> of version V in the sequential part of versioned
						structure VDST. The function <dfn>precedingVersion</dfn>(V; VDST) =
							<a>predecessor</a>(V; <a>sequentialPart</a>(VDST)) is defined for all
						non-intial versions V of VDST; otherwise, it is undefined. </p>
					<p>Similarly, we define the concepts of <dfn>terminal version</dfn>,
							<dfn>succeeding version</dfn>, and functions
							<dfn>hasTerminalVersion</dfn>, <dfn>terminalVersionOf</dfn>, and
							<dfn>succeedingVersion</dfn>.</p>
					<p class="ednote">Here is where it appears to be important to use the named
						associative tree as the version, or to refer to version by name rather than
						by content. Because the same content can be associated with more than one
						version name in the same versioned structure, so the preceding version of
						that content would not be uniquely defined.</p>
					<p>We say that each non-initial version <dfn>revises</dfn> its preceding
						version. We define <dfn>revises(U, V; VDST)</dfn> for all versions U and V
						of VDST, with the value true whenever V=<a>precedingVersion</a>(U; VDST);
						otherwise, it is false. </p>
					<p class="note">Because of the requirement for total order in the sequential
						part, version structures do not branch.</p>
					<p> The sequential part MAY be finite, semi-infinite, or bi-infinite.</p>
					<p>The ordered set of version names of a versioned structure VDST is denoted by
							<dfn>versionNames</dfn>(VDST). </p>
					<p>The function <dfn>isVersionNameOf</dfn>(n, VDST) is true if n is a member of
							<a>versionNames</a>(VDST); otherwise, it is false.</p>
					<p>The function <dfn>versionContent</dfn>(n; VDST) is defined provided
							<a>isVersionNameOf</a>(n, VDST) is true, with value being the element (a
						named k-th order associative tree) of the sequential part of VDST having
						name n. Otherwise, the function is undefined.</p>
					<p>The function <dfn>versionMap</dfn>(VDST) has the value of the mapping from
						the set of version names to the corresponding values of
							<a>versionContent</a>.</p>
					<p>The function <dfn>hasNext</dfn>(n; VDST) = <a>hasNext</a>(n;
							<a>versionNames</a>(VDST)) is true iff n is the name of a non-terminal
							<a>version</a> of VDST</p>
					<p>The function <dfn data-lt="next">next(n; VDST)</dfn> is defined provided
							<a>hasNext</a>(n; VDST) is true, and has the value <a>next</a>(n;
							<a>versionNames</a>(VDST)).</p>
					<p>We define a constuctor of <a>versioned data structures</a> as a basic
						operation <dfn data-lt="Versioned-NEW">Versioned-NEW<sub>k</sub></dfn>, k =
						1, 2, ..., that takes the following arguments.</p>
					<ol>
						<li>The ordered set VI = [VN, &le;<sub>VN</sub>] of version names of the
							data structure. </li>
						<li>The mapping DSTM from the set VN<sub>ext</sub> = VN &cup; {ASSOC} to
								<a>data structures</a> of order k-1 or less that specifies the
							sequential and associative part of the data structure. </li>
						<li><dfn>ASSOC</dfn> is a reserved name used to streamline the
							definitions.</li>
					</ol>
					<p>The semantics are as follows.</p>
					<p><a>Versioned-NEW</a><sub>k</sub>(VI, DSTM) = [ DSTM(ASSOC) , <a>Seq-NEW</a>(
						VI', DSTM' ) ]</p>
					<p>where VI = [VN, &le;<sub>VN</sub>], </p>
					<p>DSTM'(n) = <a>Solitary-NEW<sub>k</sub></a>(n, DSTM(n)) for n &in; VI, and</p>
					<p>VI' = [VN', &le;<sub>VN</sub>] where VN' = {n &in; VN | <a>hasNext</a>(n; VI)
						= False or DSTM(n) &ne; DSTM(<a>next</a>(n; VI))}</p>
					<p class="note">The constructor <a>Versioned-NEW<sub>k</sub></a> ensures that
						revisions are not vacuous by reducing the ordered set of version names as
						needed.</p>
					<aside class="example">
						<p>An important usecase is to view versioned structures from different
							ordering perspectives. For example, streams with multiple temporal
							characteristics may be represented by repositories that differ primarily
							in regard to version order, rather than version content. In this
							example, we illustrate the use the functions defined above to describe a
							re-ordering of versions. </p>
						<p>Let VDST = <a>Versioned-NEW<sub>k</sub></a>(VI, DSTM), where VI = [VN,
								&le;<sub>VI</sub>].</p>
						<p>Let PM be a bijection from VN to itself. The mapping PM, called a
							permutation of VI, defines a totally-ordered set VI' = [VN,
								&le;<sub>VI'</sub>] where PM(x) &le;<sub>VI'</sub> PM(y) iff x
								&le;<sub>VI</sub> y.</p>
						<p>We define an operator <dfn>Versioned-PERMUTE</dfn>(VDST, PM) with
							signature [<a>versioned</a><sub>k</sub>, ℘(<a>versionNames</a>(VDST))]
							=> <a>versioned</a><sub>k</sub></p>
						<p>with semantics <a>Versioned-PERMUTE</a>(VDST, PM) = Versioned-NEW(VI',
							DSTM).</p>
					</aside>
				</section>
				<section id="def-kth-order-rdf-repository">
					<h4>k-th Order RDF Repositories</h4>
					<p>A <dfn
							data-lt="k-th Order RDF Repositories|k-th Order Repository|k-th Order Repositories|RDF Repository|RDF Repositories|repository|repositories"
							>k-th Order RDF Repository</dfn>, k = 1, 2, ... is a <a>k-th order
							versioned data structure</a> that satisfies the following requirements. </p>
					<ol>
						<li>It's <a>associative part</a> is an <a>associative tree</a> of k-1-th
							order or less (possibly empty).</li>
						<li>The <a>contents</a> of its <a>versions</a> are also <a>associative
								trees</a> of k-1-th order or less.</li>
					</ol>
					<p class="note">A k-th Order RDF Repository, k &gt; 0, may be viewed as a k-th
						Order RDF Dataset with the additional structure of a total order on the
							<a>associative trees</a> in its <a>named part</a>. However, the
						additional requirements on adjacent contents being distinct emphasizes the
						motivation of this definition as a model of a mutable associative tree,
						where each element of the sequence describes a named "snapshot" of the
						associative tree, and the requirement for distincness between adjacent
						snapshots enforces non-vacuous revisions.</p>
					<p class="ednote">To be clarified in Eval section: The associative part of the
						repository plays the role of background knowledge, which is unioned with
						every snapshot prior to query.</p>
					<p>We define a Repository Constructor as a basic operation <dfn
							data-lt="Repository-NEW">Repository-NEW<sub>k</sub></dfn>, k = 1, 2,
						..., that takes the following arguments.</p>
					<!--
					<ol>
						<li>The <a>associative tree</a> of order k-1 or less that is the associative
							part of the repository, or the reserved word <a>NONE</a>, indicating the
							repository has no associative part.</li>
						<li>The ordered set of version names of the repository. </li>
						<li>The mapping from the set of version names to <a>associative trees</a> of
							order k-1 or less that defines the versions of the repository. </li>
					</ol>
					-->
					<ol>
						<li>The ordered set VI = [VN, &le;<sub>VN</sub>] of version names of the
							repository. </li>
						<li>The mapping ATM from the set VN<sub>ext</sub> = VN &cup; {ASSOC} to
								<a>associative trees</a> of order k-1 or less that specifies the
							sequential and associative part of the repository. </li>
					</ol>
					<p>The semantics of the <a>Repository-NEW<sub>k</sub></a> constructor are as
						follows.</p>
					<p><a>Repository-NEW<sub>k</sub></a>(VI, ATM) =
						<a>Versioned-NEW<sub>k</sub></a>(VI, ATM)</p>
					<p class="note"><a>Repository-NEW<sub>k</sub></a> is simply a restriction of
								<a>Versioned-NEW<sub>k</sub></a> with respect to the mapping in the
						second argument, which must have a codomain that is <a>associative trees</a>
						of order k-1 or less.</p>
					<p class="note">The <a>Versioned-NEW</a> constructor ensures that the repository
							<i>revisions</i> are non-vacuous.</p>
					<p>In addition to constructing a repository in its entirety with
								<a>Repository-NEW<sub>k</sub></a>, we define a basic operation
							<dfn>Append2Repository</dfn> which creates a new repository by adding a
						version to the input repository. <a>Append2Repository</a> does not change
						the associative part of a repository.</p>
					<p>The arguments of <a>Append2Repository</a><sub>k</sub>, k = 1, 2, ..., are</p>
					<ol>
						<li>The k-th order input repository, R, to be modified.</li>
						<li>The new repository version name, n, which must be distinct from version
							names of the input repository; i.e. n &notin;
							<a>versionNames</a>(R).</li>
						<li>The associative tree of order (k-1) or less that is to be the content of
							the new repository version.</li>
					</ol>
					<p>The semantics are</p>
					<p><a>Append2Repository</a><sub>k</sub>(R, n, AT) =
								<a>Repository-NEW<sub>k</sub></a>(VI', ATM') where</p>
					<p>VI = <a>versionNames</a>(R) and VI' = <a>Cons</a>(n, VI),</p>
					<p>ATM = <a>versionMap</a>(R) and ATM' = ATM &cup; {n => AT}</p>
					<p>assuming n &notin; <a>versionNames</a>(R).</p>
					<p class="ednote">To be clarified in the section on the extension of Eval to
						repositories: there is an entailment regime, called e.g. "provenance
						entailment regime", that has additional entailments beyond those of the
						simple entailment regimes in that the name of each non-initial version is
						related to the name of its previous version by the <a
							href="https://www.w3.org/TR/2012/WD-prov-o-20120503/#wasRevisionOf"
							>prov:wasRevisionOf</a> property. </p>
					<p class="ednote">To be clarified in the section on the extension of Eval to
						repositories: An objective for the provenance entailment regime is that it
						be monotonic with respect to repository updates. From this perspective, it
						would also be ok to include entailment regarding the initial version.
						Therefore, we define a new property <code>repo:isInitialVersion</code> that
						relates each version name of a repository to a boolean literal value. </p>
					<p class="ednote">This is not yet a sufficient analysis of the similarities and
						differences between a second-order repository and a Graph Store. Move to
						Examples section? A second-order <a>RDF Repository</a> is similar to a Graph
						Store, but with the additional structure that every version is named (albeit
						the name may be a blank node). </p>
					<p class="ednote">Needs more explanation, examples: Where Update Operations are
						conceived as functional specifications for transitions of the state of a
						Graph Store, for a RDF Repository these operations play the role of helper
						functions used in the "lazy" construction of the RDF Repository. </p>
					<p class="ednote">Needs more explanation, examples: To use a second-order
							<a>repository</a> to emulate a <a>Graph Store</a>, the input for query
						and update operations would have to be limited to some "current
							<a>version</a>", and the <a>associative part</a> of the repository would
						be empty. The execution of an <a>Update operation</a> would move the
						"current <a>version</a> pointer" to the <a>succeeding version</a>. </p>
				</section>
				<section id="def-named-kth-order-repository">
					<h4> k-th Order Solitary Repository Association</h4>
					<p>A <dfn
							data-lt="k-th Order Solitary Repository Associations|Solitary Repository Association|Solitary Repository Associations"
							>k-th Order Solitary Repository Association</dfn> is a k-th order
							<a>solitary association</a> whose content is a (k-1)-th order
							<a>repository</a>. </p>
					<p class="ednote">To be clarified in the section on the extension of Eval on
						Solitary Repository Associations: Under the provenance entailment regime a
							<a>Solitary Repository Association</a> has additional entailments that
						the name of each version is related to the name of the parent RDF Repository
						by the <a
							href="https://www.w3.org/TR/2012/WD-prov-o-20120503/#specializationOf"
							>prov:specializationOf</a> property. </p>
					<p class="ednote">To be clarified in the section on the extension of Eval to
						Solitary Repository Associations: For a Solitary Repository Association,
						e.g. within a store, the provenance entailment regime also includes an
						additional property, <code>repo:isInitialVersionOf</code>, with object being
						the name of the repository. A new namespace (prefix "repo") needs to be
						defined. These properties can be used to define operations on <a>data
							sequences</a> and <a>data structures</a> that extract parts of the
						sequence (e.g. foot - the initial version, and subsequences related to that,
						such as the first 10 versions) that are monotonic relative to update
						operations. </p>
					<p class="ednote">To be clarified in the section on the extension of Eval to
						repositories and Solitary Repository Associations: a "repository structure
						entailment regime" could be defined as an extension of the monotonic
						provenance entailment regime, relaxing the requirement for monotonicity with
						respect to update operations. This regime could then include entailments
						regarding the terminal version, using <code>repo:isTerminalVersion</code>
						and <code>repo:isTerminalVersionOf</code>. These properties could be used as
						the basis for basic operations on <a>data sequences</a> and <a>data
							structures</a> that extract parts of the sequence, e.g. head, tail and
						subsequences related to these) that are nonmonotonic relative to update
						operations). </p>
				</section>
			</section>
			<section id="def-stores">
				<h3>Stores</h3>
				<p>The new operators introduced in this section are summarized in the following
					table.</p>
				<table>
					<thead data-include="table-head-syntax.html" data-include-sync="true"></thead>
					<tbody data-include="store-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
				</table>
				<section id="def-kth-order-store">
					<h4>k-th Order RDF Store</h4>
					<p>A <dfn
							data-lt="k-th Order RDF Stores|k-th Order Store|k-th Order Stores|RDF Store|RDF Stores|Store|Stores"
							>k-th Order RDF Store</dfn>, k &ge; 2, is a special case of <a>k-th
							order versioned data structure</a>.</p>
					<p> A (k+2)-th order RDF Store, k = 0, 1, ..., is a (k+2)-th order versioned
						data structure STR with the following properties. <ul>
							<li>The ordered set SI = <a>versionNames</a>(STR) contains the
									<dfn>version names of the store</dfn>.</li>
							<li>STR has an associative part ADST = <a>associativePart</a>(STR). </li>
							<li>The default part of ADST, <a>defaultPart</a>(ADST) is a (k+1)-th
								order repository, called the <dfn>default repository of the
									store</dfn>, and denoted <a>repositoryOf</a>(<a>DEFAULT</a>,
								STR).</li>
							<li>The names of the associative part of the store, <a>names</a>(ADST)
								are called the <dfn>repository names of the store</dfn>, denoted
									<dfn>repositoryNames</dfn>(STR). </li>
							<li>For each name n &in; <a>repositoryNames</a>(STR), the corresonding
								content <a>content</a>(n, ADST) is a (k+1)-th order repository,
								denoted <dfn>repositoryOf</dfn>(n, STR), called the <dfn>repository
									for name n of the store</dfn> STR. </li>
							<li>The <dfn>repository map</dfn> of the store, denoted
									<dfn>repositoryMap</dfn>, is the mapping from the extended set
								of repository names, <a>Ext-DEFAULT</a>(<a>repositoryNames</a>(STR)
								) to the corresponding repositories of the store, <a>content</a>(n,
								ADST). The value <a>repositoryMap</a>(ST)(n) is called the
									<dfn>repository of the store</dfn> STR for name n. </li>
							<li>Further, the repositories and versions of the store satisfy the
								following consistency requirements.</li>
							<ul>
								<li>For every repository name n in <a>repositoryNames</a>(STR),
									there is a monotonic partial mapping NM<sub>n</sub> from
										<a>versionNames</a>(STR) onto <a>versionNames</a>(
										<a>repository</a>(n, STR)); that is, from version names of
									the store to version names of the repository for name n of the
									store STR with the following properties. <ul>
										<li>The domain of NM<sub>n</sub>,
											<a>dom</a>(NM<sub>n</sub>), is an interval in the
											ordered set <a>versionNames</a>(STR).</li>
										<li>If stver is in <a>dom</a>(NM<sub>repname</sub>), let
											repver = NM<sub>repname</sub>(stver). Then <br />
											<a>content</a>(repname; <a>versionContent</a>(stver;
											STR)) = <a>versionContent</a>(repver;
											<a>repository</a>(repname; STR)) </li>
									</ul> We define a function <dfn>versionNameMap</dfn>(STR) which
									extracts these mappings from the store STR. I.e.,
										<a>versionNameMap</a>(STR)(n) = NM<sub>n</sub>. </li>
								<li>There is a monotonic (total) mapping NM<sub><a>DEFAULT</a></sub>
									from <a>versionNames</a>(STR) onto version names of the default
									repository; that is, <a>versionNames</a>(
										<a>repositoryMap</a>(STR)(<a>DEFAULT</a>) with the following
									properties <ul>
										<li>If stver in <a>versionNames</a>(STR), let repver =
												NM<sub><a>DEFAULT</a></sub>(stver). Then <br />
											<a>defaultPart</a>(<a>versionContent</a>(stver; STR)) =
												<a>versionContent</a>(repver;
												<a>repositoryMap</a>(STR)(<a>DEFAULT</a>) ) </li>
									</ul>
								</li>
							</ul>
						</ul>
					</p>
					<p>We define a constructor <dfn data-lt="constructor Store|Store-NEW"
								>Store-NEW<sub>k</sub></dfn> for <a>k-th order stores</a>, k = 2, 3,
						..., with the following arguments.</p>
					<ol>
						<li>The non-empty set RN of repository names.</li>
						<li>The mapping RM from RN<sub>ext</sub> = RN &cup; {<a>DEFAULT</a>} to
							(k-1)-th order repositories.</li>
						<li>The non-empty ordered set SI = [SV, &le;<sub>SV</sub>] of store version
							names.</li>
						<li>For each name n in RN<sub>ext</sub>, a monotonic partial function
								NM<sub>n</sub> from an interval of SI onto the <a>version names</a>
							of the associated repository, <a>versionNames</a>(
							<a>repositoryMap</a>(STR)(n) ). (The mapping NM<sub><a>DEFAULT</a></sub>
							is total.) </li>
					</ol>
					<p>The semantics of <a>Store-NEW<sub>k</sub></a> is defined as follows.</p>
					<p><a>Store-NEW<sub>k</sub></a>(RN, RM, SI, NM) =
							<a>Versioned-NEW<sub>k</sub></a>(SI, NM')</p>
					<p>where </p>
					<p> NM'(stver) = <a>Tree-UNION</a>({RP<sub>n</sub>(stver) | n &in;
							RN<sub>ext</sub>}) for stver &in; SI, where </p>
					<p> RP<sub>n</sub>(stver) = <a>Solitary-NEW</a>(n, <a>content</a>(
							NM<sub>n</sub>(stver); RM(n) ) if n &in; RN while </p>
					<p> RP<sub><a>DEFAULT</a></sub>(stver) = <a>content</a>(
							NM<sub><a>DEFAULT</a></sub>(stver); RM(<a>DEFAULT</a>) ) and </p>
					<p> NM'(ASSOC) = <a>Tree-UNION</a>( RM( RN<sub>ext</sub> ) ). </p>
					<aside class="note">
						<p>If STR = <a>Store-NEW<sub>k</sub></a>(RN, RM, SI, NM), then</p>
						<ul>
							<li><a>repositoryNames</a>(STR) = RN.</li>
							<li><a>repository</a>(n; STR) = RM(n) for n &in; RN<sub>ext</sub>.</li>
							<li><a>versionNames</a>(STR) = SI.</li>
							<li><a>associativePart</a>(STR) = NM'(ASSOC) = <a>Tree-UNION</a>( RM(
									RN<sub>ext</sub> ) ).</li>
						</ul>
					</aside>
					<p>An important usecase is to view repositories from different ordering
						perspectives. For example, streams with multiple temporal characteristics
						may be represented by repositories that differ primarily in regard to
						version order, rather than version content. For this purpose, we extend the
						constructor <a>Store-NEW<sub>k</sub></a> so that the mapping from store
						versions to repository versions is not required to be monotonic. The
						constructed store will hold a different repository than the constructor
						input, but different only with respect to the order of versions, not their
						content, and therefore this reordered repository can be lazily
						materialized.</p>
					<p>The only difference in the semantics of <a>Store-NEW</a> is as follows.</p>
					<p> NM'(ASSOC) = <a>Tree-UNION</a>({ <a>Versioned-PERMUTE</a>( RM(n) , PM(n) ) |
						n &in; RN<sub>ext</sub>} ) </p>
					<p>where PM(n) is the permutation of <a>versionNames</a>(RM(n)) defined by the
						mapping NM<sub>n</sub>.</p>
					<p class="ednote">In this extended signature of <a>Store-NEW</a>, there needs to
						be a constraint on the mapping NM so that it does define a permutation of
						the repository versions. E.g. This can take the form of a required
						decomposition into a monotonic partial mapping NM' (as before) composed with
						a permutation PM of the repository version names (NM = PM o NM').</p>
					<p>That is, if VI' = <a>codom</a>(PM(n)), then <a>previousTo</a>(NM(sn1),
						NM(sn2); VI') iff <a>previousTo</a>(sn1, sn2; SI)</p>
					<p class="ednote">The function <a>repository</a> that retrieves repositories
						from the store must return the permuted repository so that the consistency
						requirements are satisfied. An implementation may also provide access to the
						original repository from which the store was constructed, so that the
						laziness of repository construction can be perpetuated. However, this should
						be considered an implementation detail. In particular, when comparing two
						stores for syntactic equality, only the permuted repositories should be
						considered, not the original repositories.</p>
					<p>In addition to constructing a store in its entirety with
								<a>Store-NEW<sub>k</sub></a>, we define a basic operation
							<dfn>Append2Store</dfn> which creates a new store by adding a version to
						the input store. <a>Append2Store</a> does not change the associative part of
						a store, and it specifies the new store version through new versions of its
						repositories.</p>
					<p>The arguments of <a>Append2Store</a><sub>k</sub>(STR, svn, ATM, RM, DN)
						are</p>
					<ol>
						<li>The k-th order input store STR to be modified, with RN =
								<a>repositoryNames</a>(STR), RM = <a>repositoryMap</a>(STR), SI =
								<a>versionNames</a>(STR), NM = <a>versionMap</a>(STR). </li>
						<li>The new store version name svn, which must be distinct from previous
							store version names (svn &notin; SI).</li>
						<li>A specification of new versions for repositories of the input store via
							a mapping ATM from a subset of the extended repository names of the
							input store ( <a>dom</a>(ATM) &sube; <a>Ext-DEFAULT</a>(STR) ) to
								<a>solitary-association-trees</a> of order (k-1) or less, where the
							name of the solitary association is new as a version name for that
							repository.</li>
						<li>A specification of repositories to be added to the store via a mapping
							RM from zero or more repository names to repositories of order (k-1)
							having exactly one version. The repository names MUST be new for the
							store. </li>
						<li>A set DN of zero or more repository names of the input store that are to
							be dropped. This set MUST be disjoint from the repository names in the
							domain of ATM.</li>
					</ol>
					<p>An <a>Append2Store</a> operation cannot be vacuous; it must append to at
						least one repository (default or named) of the input store, or add at least
						one new named repository, or drop at least one named repository. </p>
					<p>The semantics of <a>Append2Store</a> are defined in terms of the
								<a>Store-NEW<sub>k</sub></a> constructor and the
							<a>Append2Repository</a> basic operations. The semantics of
							<a>Append2Store</a> are as follows.</p>
					<p><a>Append2store</a><sub>k</sub>(STR, svn, ATM, RM'', DN) =
							<a>Store-NEW</a><sub>k</sub>(RN', RM', SI', NM')</p>
					<p>From the input store STR, we have</p>
					<ol>
						<li>RN = <a>repositoryNames</a>(STR)</li>
						<li>RM = <a>repositoryMap</a>(STR)</li>
						<li>SI = <a>versionNames</a>(STR)</li>
						<li>NM = <a>versionNameMap</a>(STR)</li>
					</ol>
					<p>Let</p>
					<ul>
						<li>RN' = RN &cup; <a>dom</a>(RM'')</li>
						<li>RM' is a mapping defined on RN'.</li>
						<li>For each n in the domain of ATM, let RM'(n) =
							<a>Append2Repository</a>(RM(n), ATM(n) ) </li>
						<li>For each n in the domain of RM'', let RM'(n) = RM''(n).</li>
						<li>For n in RN - <a>dom</a>(RM) - DN, let RN'(n) = RN(n).</li>
						<li>For n in DN, let RM'(n) = <a>TerminateRepository</a>(RM(n))</li>
						<li>SI' = <a>Cons</a>(svn, SI)</li>
						<li>NM' is a mapping defined on SI'</li>
						<li>For n in <a>dom</a>(ATM), NM'<sub>n</sub> = NM<sub>n</sub> &cup; {svn =>
								<a>name</a>(ATM(n))}</li>
						<li>For n in <a>dom</a>(RM''), NM'<sub>n</sub> = {svn =>
							<a>versionName</a>(RM''(n))}</li>
						<li>For n in RN - <a>dom</a>(ATM) - DN, NM' = NM &cup; {svn => NM(
								<a>greatest</a>(SI) ) }</li>

					</ul>
					<p class="ednote">Need to define <dfn>TerminateRepository</dfn>(R) =
							<a>Append2Repository</a>(R,
							<a>Solitary-NEW</a><sub><a>order</a>(R)</sub>( <a>NIL</a>, {}) </p>
					<p>where <dfn>NIL</dfn> is a reserved word used to as the version name for a
						repository that is permanently cleared (i.e. dropped from the store).</p>
					<p class="ednote">Need to define <dfn>versionName</dfn>(R) for repositories with
						only one version to return the one member of <a>versionNames</a>(R).</p>
					<!--
					<p>Given the sequence of store versions (i.e. the sequential part of the store) and
						the mappings from store version names to repository version names, we can
						reconstruct the sequential parts of the repositories. To describe this
						construction explicitly, we need a few additional basic operations.</p>
					<p>Let <dfn>Distinct</dfn> be a basic operation on sequences that collapses
						adjacent identical elements into a single element, producing a new
						sequence.</p>
					<p> Let <dfn>Map</dfn> be a basic operation on sequences that applies a unary
						function to every element of the sequence, producing a new sequence.</p>
					<p>We define the basic operation <dfn>Restrict</dfn> whose signature is a first
						argument of a <a>versioned data sequence</a> of k-th order or
						less, for some fixed k, and second argument a name or set of names, and
						output is a <a>data sequence</a> of associative trees of (k-1)-th order or less.</p>
					<p> Let DSQ = [ [n<sub>i</sub>, DSQ<sub>i</sub>, k+1]]<sub>i in <i>I</i></sub>.
						Let I<sub>m</sub> = {i|i in I such that m is in <a>names</a>(DSQ<sub>i</sub>)}.
						Further let I<sub>M</sub> = Union<sub>m in M</sub> I<sub>m</sub>. Then </p>
					<p> Restrict(DSQ, name) = Distinct( [<a>content</a>(name, DSQ<sub>i</sub>)]<sub>i in
									<i>I<sub>name</sub></i></sub> ) </p>
					<p> = Distinct( Map( DSQ, (λx.<a>content</a>(name, <a>content</a>(x)) ) )</p>
					<p> Restrict(DSQ, names) = Distinct( [ <a>Tree-UNION</a>({<a>content</a>(name,
							DSQ<sub>i</sub>)|name in names}) ]<sub>i in
							<i>I<sub>names</sub></i></sub> ) </p>
					<p> = Distinct( Map( DSQ, (λx.<a>Tree-UNION</a>({<a>content</a>(name, <a>content</a>(x)|name in
						names})) ) )</p>
					<p>Similarly, we define <dfn>Restrict-DEFAULT</dfn> on a versioned structure of 
					    k-th order, for some fixed k, as
						follows.</p>
					<p> Restrict-DEFAULT(DSQ) = Distinct( [<a>defaultPart</a>( DSQ<sub>i</sub>)]<sub>i in
								<i>I</i></sub> ) </p>
					<p> = Distinct( Map( DSQ, (λx.<a>defaultPart</a>(<a>content</a>(x)) ) )</p>
					<p class="ednote">Is there a need for a combination union of default and
						named?</p>
					<p>Using the store history, we can form the "union" of histories of repositories
						that are in the store (as named and/or default), because the relative order
						of revisions of these repositories has been recorded in the history of the
						store.</p>
					<p> Let R<sub>i</sub> = <a>content</a>(name<sub>i</sub>, <a>associativePart</a>(S)), and
							R<sub>j</sub> = <a>content</a>(name<sub>j</sub>, <a>associativePart</a>(S)), for some
							name<sub>i</sub> and name<sub>j</sub> in <a>names</a>(S). Then the <dfn>sequential
							union</dfn> of named repositories [name<sub>i</sub>, R<sub>i</sub>, k]
						and [name<sub>i</sub>, R<sub>i</sub>, k] in the context of store S is:</p>
					<p> Sequential-UNION(S, {name<sub>i</sub>, name<sub>j</sub>}) = Restrict(
						<a>sequentialPart</a>( S ), {name<sub>i</sub>, name<sub>j</sub>} ) </p>
						-->
					<p class="ednote">The intended semantics, under any entailment regime, of a
						k+1-th Order <a>RDF Store</a> is derived from that of the corresponding
						k+1-th Order RDF Repository (the sequential part of the store), supplemented
						by that of its member k-th Order Repositories, possibly augmented (e.g. in
						the provenance regime) by entailments that link the two. </p>
				</section>
				<section id="def-store-transformations">
					<h4>Store Transformations</h4>
					<section id="def-general-transformation">
						<h5>General Store Transformation</h5>
						<p>We define a basic operation <dfn>StoreTransformation</dfn><sub>k</sub>
							that takes a <a>store</a> of order k as an input and outputs a
								<a>store</a> of order k to perform a general restructuring of the
							content of the input store, including subsampling, duplication, change
							of context, and reordering. The transformation treats the graphs of the
							input store as indivisible units, except that union is possible. </p>
						<p>For an ordered set SI = [SV, &le;<sub>SV</sub>] of <a>RDF Names</a>, let
								<dfn>Ext-ASSOC</dfn>(S) be the partially ordered set [SV ∪ {ASSOC},
								&le;<sub>SV</sub>]. For a set S of names, let
							<dfn>Ext-DEFAULT</dfn>(S) = S ∪ {<a>DEFAULT</a>}.</p>
						<p>For store STR, let <dfn>namePairs</dfn>(STR) be a subset of
								<a>Ext-ASSOC</a>(<a>versionNames</a>(STR)) x <span
								style="white-space: nowrap;"
								><a>Ext-DEFAULT</a></span>(<a>names</a>(<a>associativePart</a>(STR)))
							such that [stver, repo] is in NP provided stver is a member of
								<a>Ext-ASSOC</a>(<a>versionNames</a>(STR)) and repo is in
								<a>names</a>(<a>versionContent</a>(stver; STR).</p>
						<p>The input arguments of <a>StoreTransformation</a><sub>k</sub> are as
							follows. </p>
						<ol>
							<li>The input <a>store</a> STR of order k. Let SI =
								<a>versionNames</a>(STR), SI<sub>ext</sub>= <a>Ext-ASSOC</a>(SI), RP
								= <a>names</a>(<a>associativePart</a>(STR)), and RP<sub>ext</sub> =
								Ext-DEFAULT(RP). Let NP = <a>namePairs</a>(STR), and RV(n) =
									<a>versionNames</a>(<a>content</a>(n, STR)). <br /> Note: SI is
								the ordered set of store version names of the input store, while RP
								is the set of repository names of the input store. NP is the set of
								pairs of names - the first name being a store version name and the
								second name being the name of a repositry present in that store
								version. RV(n) is the ordered set of version names of the repository
								with name n.</li>
							<li>An ordered set SI' of version names of the output store. Let
									SI'<sub>ext</sub> = <a>Ext-ASSOC</a>(SI').</li>
							<li>A set RP' of repository names of the output store. Let
									RP'<sub>ext</sub> = Ext-DEFAULT(RP')</li>
							<li>For each name n in RP'<sub>ext</sub>, an ordered set RV'(n) of
								version names of the corresponding output named or default
								repository. Let RV'(n)<sub>ext</sub> = Ext-ASSOC(RV'(n)).</li>
							<li>A partial mapping NM'<sub>n</sub>, for each name n in
									RP'<sub>ext</sub> from an interval of SI' onto RV'(n). Let NP' =
								{[m, n] | n in RP'<sub>ext</sub>, m in <a>dom</a>(NM'<sub>n</sub>)
								}, the set of <a>namePairs</a> of the output store.</li>
							<li>A relation Rel<sub>data</sub> on NP x NP'. This relation describes
								the subsampling, duplication, and rearrangment of associative trees
								from the input store to the output store, possibly including
								associative tree unions.</li>
						</ol>
						<p>There are certain additional constraints on the arguments or output of
								<a>StoreTransformation</a>, as follows.</p>
						<ul>
							<li>NM'<sub><a>DEFAULT</a></sub> is a total mapping on SI'.</li>
						</ul>
						<p>The semantics of <a>StoreTransformation</a><sub>k</sub> is defined as
							follows. For input (STR, SI', RP', RV', NM', Rel<sub>data</sub>),
							let</p>
						<ul>
							<li>AT<sub>m, n</sub> = <a>content</a>(n, <a>versionContent</a>(m, STR))
								for each [m, n] in NP. </li>
							<li> AT'<sub>p', n'</sub> = <a>Tree-UNION</a>({AT<sub>m, n</sub> | [ [m,
								n], [m', n']] in Rel<sub>data</sub>, NM'<sub>n'</sub>(m') =
								p'})</li>
							<li>R'<sub>n'</sub> = <a>Repository-NEW</a><sub>k-1</sub>(
									AT'<sub>ASSOC, n'</sub>, RV'(n'), { p' => AT'<sub>p',n'</sub> |
								p' in RV'(n') } ), for n' in RP'<sub>ext</sub></li>
							<li>NM'' is the mapping NM' composed with the version name substitution
								arising from the reconciliation of vacuous revisions in the
								construction of repositories R'.</li>
						</ul>
						<p>Then the value of <a>StoreTransformation</a><sub>k</sub>(STR, SI', RP',
							RV', NM', Rel<sub>data</sub>) is equal to the value of the constructor
								<a>Store-NEW</a><sub>k</sub> with the following arguments.</p>
						<ol>
							<li>RP'</li>
							<li>{n' => R'<sub>n'</sub> | n' in RP'<sub>ext</sub>}</li>
							<li>SI'</li>
							<li>NM''|<sub>RP'<sub>ext</sub></sub></li>
						</ol>
						<aside class="note">
							<p>Repository <i>revisions</i> cannot be vacuous (i.e. the content of
								adjacent version cannot be the same). This adjustment is handled by
								the constructor <a>Repository-NEW<sub>k</sub></a>. If the input
								mappings to <a>StoreTransformation</a> specify output "repositories"
								with vacuous revisions, the version names of those output
								repositories are reduced (by the constructor) to eliminate such
								revisions.</p>
							<p>Similarly, store <i>revisions</i> cannot be vacuous, and the
										<a>Store-NEW<sub>k</sub></a> constructor is defined in a way
								that handles this. See <a>Versioned-NEW<sub>k</sub></a> for
								details.</p>
						</aside>
						<aside class="example" title="Identity Transformation">
							<p>The output store is equal to the input store when the following
								hold.</p>
							<ul>
								<li>RP' = RP</li>
								<li>SI' = SI</li>
								<li>RV'(n) = RV(n) for every n in RP<sub>ext</sub></li>
								<li>Rel<sub>data</sub> is the identity relation on NP x NP, denoted
										<i>IDR</i><sub>NP</sub>
								</li>
								<li>NM'<sub>n</sub> = NM<sub>n</sub>, for each name n in
										RP'<sub>ext</sub>, where NM<sub>n</sub> is the corresponding
									mapping in the input store.</li>
							</ul>
							<p>That is,</p>
							<p>STR = StoreTransformation<sub>k</sub>(STR, SI, RP, RV,
									IDR<sub>NP</sub>, NM ) where k =<a>order</a>(STR), RP =
									<a>names</a>(<a>associativePart</a>(STR)), SI =
									<a>versionNames</a>(STR), RV = { n => RV(n) | n is in RP and
								RV(n) = <a>versionNames</a>( <a>content</a>(n,
									<a>associativePart</a>(STR) ) }, NP = <a>namePairs</a>(STR), NM
								= <a>versionNameMap</a>(STR).</p>
						</aside>
						<aside class="example" title="Subsampling a Store">
							<p>The output store is equal to the input store except for subsampling
								of the versions in one or more repositories when the following
								hold.</p>
							<ul>
								<li>RP' = RP</li>
								<li>SI' = SI</li>
								<li>RV'(n) is a subset of RV(n) for every n in RP<sub>ext</sub></li>
								<li>NM'<sub>n</sub>(m') = max( { p | m &le; m' and p =
										NM<sub>n</sub>(m) is in RV'(n) } ).</li>
								<li> Rel<sub>data</sub> = {[[m', n], [m, n]] | [m, n] is in NP and
										NM'<sub>n</sub>(m') = NM<sub>n</sub>(m) } </li>
							</ul>
							<li>Let <dfn>Subsample</dfn>(STR, RV') =
									<a>StoreTransformation</a><sub>k</sub>(STR, SI, RP, RV',
									Rel<sub>data</sub>, NM') with Rel<sub>data</sub> and NM' as
								defined above.</li>
						</aside>
						<aside class="example" title="Sequential Union of Two Repositories">
							<p>In this example, the output store is equal to the input store except
								for the sequential union of a set of store repositories into a new
								named repository. The versions of the selected repositories that are
								associated with a common store version are unioned to become a
								version of the new repository, associated with the same store
								version. </p>
							<ul>
								<li>UN &sube; RP be the names of the repositories of STR that are to
									be unioned,</li>
								<li>r' is the (new) name of the result of the union,</li>
								<li>RP' = (RP ∪ {r'}) - UN </li>
								<li>SI' = SI</li>
								<li>RV'(n) = RV(n) for every n in RP<sub>ext</sub> - UN</li>
								<li>RV'(r') = RV<sub>new</sub></li>
								<li>if n is in RP - UN, then [[m, n], [m', n']] belongs to
										Rel<sub>data</sub> iff m' = m and n' = n.</li>
								<li>if n is in UN, then [[m, n], [m', n']] belongs to
										Rel<sub>data</sub> iff n' = r', [m, n] is in NP, and m' = m
									. </li>
								<li>NM'<sub>n</sub> = NM<sub>n</sub>, for each name n in
										RP'<sub>ext</sub> - UN.</li>
							</ul>
							<p>Let <dfn>Sequential-UNION</dfn>(STR, UN, r', RV<sub>new</sub>) =
									<a>StoreTransformation</a><sub>k</sub>(STR, SI, RP', RV',
									Rel<sub>data</sub>, NM') with RP', RP', Rel<sub>data</sub> and
								NM' as defined above. </p>
						</aside>
						<aside class="example" id="ex-rename" title="Renaming Operation">
							<p> A new store may be created using a name substitution Subst that maps
								all names that appear in the store to names. Since names may be used
								both in the structural aspects, e.g. version or repository names,
								and in the content, then both must be subject to the
								substitution.</p>
							<p>Subst may not substitute for or with the reserved names
									<a>DEFAULT</a> or ASSOC.</p>
							<p>Substitutions into an ordered set preserve the order, e.g as if the
								order assertions were materialized and subject to substitution.</p>
							<p><dfn data-lt="Rename">Rename(STR, <a>Subst</a>)</dfn> =
										<a>Store-NEW<sub>k</sub></a>( <a>Subst</a>(RP),
								<a>Subst</a>(R), <a>Subst</a>(SI), <a>Subst</a>(NM)) where
									<dfn>Subst</dfn> is a name substitution mapping.</p>
							<p>The name-substituted store will entail a substituted version of the
								entailments of the original store in simple and structural
								entailment regimes.</p>
						</aside>
						<aside class="example" id="ex-window" title="Count-Based Window Operation">
							<p> We define some auxiliary functions to assist with count-based window
								operations. </p>
							<p> Let <dfn data-lt="Comb">Comb<sub>p</sub></dfn>(SQ, E) select from a
								sequence SQ containing element E the elements of SQ that are offset,
								with respect to order, an integer multiple of p from element E. That
								is, elements E'' such that there are <span
									style="white-space: nowrap;">exactly k * (p) elements E' with E
									&lt; E' &le; E'' or E'' &lt; E' &le; E</span>. </p>
							<p>Let <dfn data-lt="Interval">Interval<sub>p</sub></dfn>(SQ) be the
								ordered set of all intervals of length p in SQ, with order by
								minimal element, and Interval<sub>p</sub>(SQ, E) be the interval of
								length p in SQ whose minimal element is E.</p>
							<p>Let <dfn data-lt="Floor">Floor<sub>p</sub></dfn>(SQ, E) = { F' => F |
								F' is in <a>Interval</a><sub>p</sub>(SQ, F) and F is in
									<a>Comb</a><sub>p</sub>(SQ, E) }</p>
							<!--
							<p>We define a basic operation <dfn>Window</dfn><sub>n, p</sub>(A, a) =
									Comb<sub>p</sub>( Interval<sub>n</sub>(A),
								Interval<sub>n</sub>(A, a) ) where n and p are positive integers,
								and A is a totally-ordered set, and a is an element in A.</p>
								-->
							<p>The functions <a>Comb</a>, <a>Interval</a> can be used to define
								window operators on sequences. For example, we define
									WindowRel<sub>p, q</sub>(SQ, E) = { [F, F'] | if F' is in
									Comb<sub>q</sub>(SQ, E) and F is in Interval<sub>p</sub>(SQ, F')
								} </p>
							<p>A <a>store</a> is a more complex structure than a sequence, due to
								the synchronization between repository and store version contents.
								However, the <a>Comb</a> and <a>Interval</a> functions also form the
								basis of a window operation on stores, as follows.</p>
							<p>Consider a store STR and let k = <a>order</a>(STR), SI =
									<a>versionNames</a>(STR), SI<sub>ext</sub>=
								<a>Ext-ASSOC</a>(SI), RN =
								<a>names</a>(<a>associativePart</a>(STR)), and RN<sub>ext</sub> =
								Ext-DEFAULT(RP). Let NP = <a>namePairs</a>(STR), RV(n) =
									<a>versionNames</a>(<a>content</a>(n, STR)), and NM =
									<a>versionNameMap</a>(STR).</p>
							<p>Let [[m, n], [m', n]] belong to WindowRel<sub>p, q</sub>(STR, N,
									NM<sub>0</sub>) iff [m, n] is in NP, n is in N =
									<a>dom</a>(NM<sub>0</sub>), v' is in RV'(n) =
									<a>Comb</a><sub>q</sub>(RV(n), NM<sub>0</sub>(n)), v is in
									<a>Interval</a><sub>p</sub>(RV(n), v') where v =
								NM<sub>n</sub>(m), v' = NM<sub>n</sub>(m'). </p>
							<p>Then we define the basic operation <dfn>Window</dfn>(STR, n, p, q,
									v<sub>0</sub>) = <a>StoreTransformation</a><sub>k</sub>( STR,
								{n}, RV'(n), {<a>DEFAULT</a>=>{}, n=>RV'(n)}, {<a>DEFAULT</a>=>{},
								n=> <i>IDM</i><sub>n</sub>}, WindowRel<sub>p, q</sub>(STR, {n}, {n
								=> v<sub>0</sub>})) where</p>
							<ul>
								<li>RV'(n) = Comb<sub>q</sub>(RV(n), NM<sub>0</sub>(n))</li>
								<li>RV(n) = <a>versionNames</a>(<a>content</a>(n, STR))</li>
								<li><i>IDM</i><sub>n</sub> is the identity mapping on RV'(n)</li>
							</ul>
							<p class="ednote">If we use an expression rather than interval of fixed
								size, we can work towards semantic windowing based on a query of the
								structural metadata.</p>
						</aside>
						<aside class="example" title="Repository Extraction">
							<p>The <dfn>Repository-EXTRACT</dfn> operation takes a store STR and a
								set of repository names N, returning a substore that contains only
								repositories whose names are in N.</p>
							<p>Repository-EXTRACT<sub>k</sub>(STR, N) =
									<a>StoreTransformation</a><sub>k</sub>(STR, SI, RP', RV', NM',
									Rel<sub>data</sub>) </p>
							<p>where</p>
							<ul>
								<li>RP' = RP &cap; N </li>
								<li>RV' is the restriction of RV to RP'</li>
								<li>NM' is the restriction of NM to RP'<sub>ext</sub></li>
							</ul>
						</aside>
					</section>
					<!--
					<section id="def-window-transformation">
						<h5>Window Functions on Stores</h5>
						<p>The RDF Stream document defines window operations on streams. We define
							here a basic operation, called <dfn>Restrict-FILTER</dfn> that performs
							a more general transformation on stores, which can be specialized to
							implement the window function on streams that are implemented through
								<a>stores</a>.</p>
						<p>The signature of <a>Restrict-FILTER</a> is like <a>Restrict</a>, except
							it has an extra argument which is a pattern. The value of the operation
							is a subsequence of the corresponding value of Restrict, but filtered to
							include only those elements where there is a non-empty result from
							applying the query to the contents of the associated version of the
							store. </p>
						<p>We next define a basic operation <dfn>Sequence-UNION</dfn> that operates
							on <a>data sequences</a> of associative trees of k-th order or less. The result
							is the value of applyling <a>Tree-UNION</a> to the set of all
							elements in the sequence. That is,</p>
						<p>Sequence-UNION([D<sub>i</sub>]<sub>i in <i>I</i></sub>) =
								<a>Tree-UNION</a>({D<sub>i</sub>|i in <i>I</i>})</p>
						<p>Finally, we define a basic operation <dfn>Window</dfn> that takes as
							first argument a store, and second argument is a sequence of patterns.
							For each pattern in the sequence, the operation Restrict-FILTER is
							performed, and then Sequence-UNION is applied to the result, generating
							a sequence of associative trees as the final result.</p>
						<p>That is,</p>
						<p><a>Window</a>(STR, [P<sub>i</sub>]<sub>i in <i>I</i></sub>)=
							[Sequence_UNION(Restrict_FILTER(STR, P<sub>i</sub>))]<sub>i in
								<i>I</i></sub></p>
					</section>
					-->
				</section>
				<section>
					<h4>Connection Between Repositories and Stores</h4>
					<p>Every <a>k-th order store</a> can be converted into a k-th order repository
						by keeping the sequential part the same, and replacing the associative part
						of the store with the default part of the associative part of the store.
						This transformation loses information; in particular, it loses the names of
						repository versions. However, the contents and order of repository versions
						is not lost; this information is preserved in the sequential part of the
						store, and can be recovered using the <a>Restrict</a> operation.</p>
					<p class="ednote"><dfn>Restrict</dfn> operator needs to be (re)-defined.</p>
					<p>Many <a>k-th order repositories</a> can be converted into a <a>k-th order
							store</a> by supplying (or minting) the additional version names
						necessary to generate (k-1)-th order repositories corresponding to the
						(k-1)-th order named associative trees in the repository version contents.
						The primary requirement for this to be possible is that once a associative
						tree name disappears from a repository version, it cannot reappear in a
						later version.</p>
				</section>
			</section>
			<section id="def-streams">
				<h3>Streams</h3>
				<p>The new operators introduced in this section are summarized in the following
					table.</p>
				<table>
					<thead data-include="table-head-syntax.html" data-include-sync="true"></thead>
					<tbody data-include="stream-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
				</table>
				<p>RDF Streams are defined in the document @@@</p>
				<p>Here we define a datastructure and some operations that allow RDF Streams to be
					emulated as first or second-order data structures.</p>
				<section id="def-timestamped-graph">
					<h4>Timestamped Graphs as Second-Order Associative Trees</h4>
					<p>We define a constructor <dfn>TSGraph</dfn> for timestamped graphs with the
						following arguments.</p>
					<ol>
						<li>An RDF graph, the default graph of the timestamped graph with the
							exception of the timestamp triple.</li>
						<li>An RDF graph containing exactly one triple, that being the timestamp
							triple</li>
						<li>An optional RDF graph which is the content of the named graph of the
							timestamped graph.</li>
					</ol>
					<p>The value of <dfn>TSGraph-NEW</dfn> is defined in terms of other operations
						in the following cases.</p>
					<ul>
						<li>TSGraph-NEW(G0, {n p t.}) =
							Associative-NEW<sub>1</sub>(G<sub>meta</sub>, {b}, {b => D0}) </li>
						<li>TSGraph-NEW(G0, {n p t.}, G1) =
								Associative-NEW<sub>2</sub>(G<sub>meta</sub>, {b}, {b => D1}) </li>
						<li>where b is a fresh blank node and </li>
						<li>D0 = <a>Tree-UNION</a>(G0, {n p t.})</li>
						<li>D1 = Associative-NEW<sub>1</sub>(<a>Tree-UNION</a>(G0, {n p t.}), {n},
							{n => G1} ) </li>
						<li>G<sub>meta</sub> = { b rsp:usesTimestampPredicate p}</li>
						<li>with the requirement that G0 contain no triples using the predicate
							p.</li>
					</ul>
					<p>To get back the parts of a timestamped graph, we define the following basic
						operations as shortcuts for CONSTRUCT-form queries of the second-order
						associative tree representing the timestamped graph under simple
						entailment.</p>
					<ul>
						<li><dfn>timestampTriple</dfn>(TSG) = {n p t.}</li>
						<li>other?</li>
					</ul>
				</section>
				<section id="def-rdf-stream-as-store">
					<h4>RDF Streams as Stores</h4>
					<p>We now show how to emulate an RDF stream as a <a>store</a>.</p>
					<section id="def-rdf-stream-as-second-order-store">
						<h4>RDF Streams as Second-Order Stores</h4>
						<p>In the case of an RDF stream where all elements are zeroth-order
							timestamped graphs (containing no named graph), we construct a stream as
							follows. </p>
						<p> Suppose the stream consists of the timestamped graphs in the sequence
								[TSG<sub>i</sub>] for i in an ordered set <i>I</i> where </p>
						<p>TSG<sub>i</sub> = TSGraph-NEW(G0<sub>i</sub>, {n<sub>i</sub>
								p<sub>i</sub> t<sub>i</sub>.}).</p>
						<p>Let S<sub>i</sub> be the stream emulation up to index i, using repository
							name rn. Then</p>
						<p>S<sub>i+1</sub> = <a>Append2Store</a><sub>2</sub>(STR, sv<sub>i+1</sub>,
								{sv<sub>i+1</sub> => G<sub><a>DEFAULT</a>, i+1</sub>}, {rn =>
								{sv<sub>i+1</sub> => G0<sub>i+1</sub>}} &cup; {n<sub>i+1</sub>
								p<sub>i+1</sub> t<sub>i+1</sub>.}, {}, {} )</p>
						<p>where sv<sub>i+1</sub> is a fresh name for the store version and </p>
						<p>G<sub><a>DEFAULT</a>, i+1</sub> =
							<a>defaultPart</a>(TSG<sub>i+1</sub>)</p>
					</section>
				</section>
			</section>
		</section>
		<section id="abstract-syntactic-categories">
			<h2>Abstract Syntactic Categories</h2>
			<p>In this section, we review the abstract syntactic categories defined in other
				recommendations and state the definitions of new abstract syntactic categories that
				support the signature definitions of new algebra operators.</p>
			<section id="existing-abstract-syntactic-categories">
				<h3>Existing Abstract Syntactic Categories</h3>
				<p class="ednote">For now, I keep this table here as a summary of definitions and
					links to the recommendations for existing datatypes. In the final document, this
					table will be moved to an appendix, or deleted. </p>
				<p>We make use of the following data structure types from other specifications in
					the RDF and SPARQL family:</p>
				<div style="text-align: left;">
					<table class="thinborder" style="margin-left: auto; margin-right: auto;">
						<caption id="existing-abstract-syntactic-categories-table"><b>Table C</b>:
							Existing abstract syntactic categories used in this specification,
							excluding data structures</caption>
						<tbody>
							<tr>
								<td><b>Syntactic Category</b></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b>
								</td>
							</tr>
							<tr>
								<td><dfn data-lt="RDF Terms">RDF-T</dfn></td>
								<td>[[!SPARQL11-Query]] <a
										href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#sparqlBasicTerms"
										>#sparqlBasicTerms</a></td>
								<td> Let <dfn>I</dfn> be the set of all <a>IRIs</a>. Let
										<dfn>RDF-L</dfn> be the set of all <a>RDF Literals</a> Let
										<dfn>RDF-B</dfn> be the set of all <a>blank nodes</a> in
										<a>RDF graphs</a>. The set of RDF Terms, RDF-T, is I ∪ RDF-L
									∪ RDF-B. </td>
							</tr>
							<tr>
								<td><dfn>V</dfn></td>
								<td>[[!SPARQL11-Query]] <a
										href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#sparqlQueryVariables"
										>#sparqlQueryVariables</a></td>
								<td>A query variable is a member of the set V where V is infinite
									and disjoint from RDF-T. </td>
							</tr>
							<tr>
								<td><dfn>expression</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b>
								</td>
							</tr>
							<tr>
								<td><dfn>Graph Pattern</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b>
								</td>
							</tr>
							<tr>
								<td><dfn>Quadpattern</dfn> or <dfn>GraphGraphPattern</dfn></td>
								<td> [[!SPARQL11-Update]] [[!SPARQL11-Query]] <a
										href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#sparqlTranslateGraphPatterns"
										>#sparqlTranslateGraphPatterns</a>
								</td>
								<td><b>Definition</b>
								</td>
							</tr>
							<tr>
								<td><dfn>Query</dfn></td>
								<td><b>Reference</b></td>
								<td><b>Definition</b>
								</td>
							</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section id="patterns">
				<h3>Patterns</h3>
				<section id="kth-order-pattern">
					<h4>k-th Order Pattern</h4>
					<p>A <dfn data-lt="k-th Order patterns|pattern|patterns">k-th Order
							pattern</dfn> (with type symbol <dfn>pattern<sub>k</sub></dfn>) is a
						generalization of <a>k-th order associative trees</a> using variables as in
						[[!SPARQL11-Query]].</p>
				</section>
			</section>
		</section>
		<section id="abstract-algebra">
			<h2>Abstract Algebra Operations</h2>
			<p>The new operators introduced in this section are summarized in the following
				table.</p>
			<table>
				<thead data-include="table-head-syntax.html" data-include-sync="true"></thead>
				<tbody data-include="operator-syntax.html" data-include-replace="true"
					data-include-sync="true"></tbody>
			</table>
			<section id="def-existing-query">
				<h3>SPARQL Query Abstract Algebra</h3>
				<section id="def-existing-query-eval">
					<h4>Eval</h4>
					<p>We define an extension of the signature, and the corresponding semantics, of
						the <dfn>eval</dfn> operation of [[!SPARQL11-Query]] that accommodates two
						styles:</p>
					<ul>
						<li>A syntactic style that uses reserved words to modify data structures,
							e.g. by casting to different types, extracting substructures or applying
							window operations.</li>
						<li>A semantic style that uses naming conventions within the IRI, e.g. with
							query strings, to indicate such modifications of the data
							structures.</li>
					</ul>
					<p> In either case, it is necessary that the transformation to the abstract
						algebra does not depend on any details of the IRI; i.e., IRIs are still
						opaque. </p>
					<p>However, it is acceptable, even typical, that the <em>semantics</em> of the
						abstract operations depend on the datatype of the arguments. </p>
					<p> Thus, we extend the binary signature of the eval function from its
						definition in [[!SPARQL11-Query]] of RDF Dataset x expression, to take a
						data structure of the various types defined in Section <a
							href="#data-structures"></a>, as first argument and an extended pattern,
						as defined in Section <a href="#patterns"></a> as second argument. </p>
					<p>All of the newly-defined data structures can be considered as specializations
						of an abstract data structure having an (optional) associative part and an
						(optional) sequential part. This same abstraction holds for:</p>
					<ul>
						<li>data structures with triples as the fundamental type (associative trees,
							repositories, stores, streams)</li>
						<li>data structures with solution mappings as the fundamental type
							(structured results)</li>
					</ul>
					<p> The semantics of eval are based on matching the pattern to the sequential
						part of the data structure, with the associative part unioned into every
						element, to obtain the sequential part of the structured result, and also
						matching the same pattern to the associative part of the data structure to
						get the associative part of the structured result. </p>
					<p>In the semantic approach, the implementer defines the naming convention of
						the query string to denote substructures of the parent data structure, e.g
						just the associative part, just the sequential part, just the terminal
						element of the sequential part, or structures derived from the parent
						structure, e.g. the sequential part with the associative part unioned into
						every element, or the result of a window operation, where subsequences from
						the sequential part are unioned to obtain a new sequence. </p>
					<p>In the syntactic approach, abstract algebra operations are employed to
						express these transformations and associate them with variables or names,
						with a syntactic transformation to and from the concrete syntax.
						<!--The motivation for the syntactic approach is to allow the same capability 
							for transformation as the semantic approach in regard to external and legacy sources.-->
					</p>
				</section>
			</section>
			<section id="def-existing-basic">
				<h3>Basic Operations</h3>
				<section id="def-existing-basic-associative tree-union">
					<h4>Dataset-UNION</h4>
					<p><dfn>Dataset-UNION</dfn> is defined in [[!SPARQL11-Update]] as a basic
						operation with the following signature:</p>
					<ul>
						<li>On the domain RDF Dataset x RDF Dataset, the range is RDF Dataset.</li>
					</ul>
					<p>The Dataset-UNION operation constructs a new <a>RDF Dataset</a> from two
						existing <a>RDF Datasets</a> by forming the union of the <a>default
							graphs</a>, and taking the union of the sets of <a>named graphs</a>,
						with the exception that if the sets of graph names of the two <a>RDF
							Datasets</a> have a non-empty intersection, the <a>graphs</a> with names
						in that intersection must be combined by set union. </p>
					<p>The semantics of <a>Dataset-UNION</a> is defined in [[!SPARQL11-Update]] as
						follows.</p>
					<p> Let DS={DG} union {(iri<sub>i</sub>, G<sub>i</sub>) | 1 ≤ i ≤ n} and DS' =
						{DG'} union {(iri'<sub>j</sub>, G'<sub>j</sub>) | 1 ≤ j ≤ m} be two RDF
						Datasets. Let further <a>graphNames</a>(DS) = { iri<sub>i</sub> | 1 ≤ i ≤ n}
						and <a>graphNames</a>(DS') = {iri'<sub>j</sub> | 1 ≤ j ≤ m}. The
							<a>Dataset-UNION</a> between DS and DS' is defined as follows: </p>
					<p><a>Dataset-UNION</a>(DS, DS') = {DG union DG'} union {(iri, G) | iri in
							<a>graphNames</a>(DS) union <a>graphNames</a>(DS')}</p>
					<p>and G defined as </p>
					<ul>
						<li>G<sub>i</sub> for iri = iri<sub>i</sub> such that iri<sub>i</sub> in
								<a>graphNames</a>(DS) minus <a>graphNames</a>(DS')</li>
						<li>G<sub>j</sub> for iri = iri'<sub>j</sub> such that iri<sub>j</sub> in
								<a>graphNames</a>(DS') minus <a>graphNames</a>(DS)</li>
						<li>G<sub>i</sub> union G<sub>j</sub> for iri = iri<sub>i</sub> =
								iri'<sub>j</sub> in <a>graphNames</a>(DS) intersect
								<a>graphNames</a>(DS')</li>
					</ul>
					<p>where union between <a>graphs</a> is defined as set-union of <a>triples</a>
						in those <a>graphs</a>.</p>
					<p> We define <dfn>Tree-UNION</dfn> as an extension of the Dataset-UNION
						operation to <a>k-th Order associative trees</a>. </p>
					<ul>
						<li>On the domain <a>k-th order associative tree</a> x k'-th order
								<a>associative tree</a>, the range of <a>Tree-UNION</a> is max(k,
							k')-th order <a>associative tree</a>.</li>
						<li>On the domain of sets of <a>associative trees</a> of order k or less,
							the range of <a>Tree-UNION</a> is <a>k-th order associative
							trees</a>.</li>
					</ul>
					<p>The semantics of <a>Tree-UNION</a> is defined by cases as follows.</p>
					<p>In the case of two arguments AT, AT':</p>
					<ul>
						<li>If AT and AT' are both zeroth-order <a>associative trees</a>, i.e.,
								<a>RDF Graphs</a>, then the value of <a>Tree-UNION</a>(AT, AT') is
							the union of the sets of <a>triples</a> in the two <a>graphs</a>. </li>
						<li>If <a>order</a>(AT) =<a>order</a>(AT') = k &gt; 0, then <br />
							<a>Tree-UNION</a>(AT, AT') = Associative-NEW<sub>k</sub>(
							<a>names</a>(AT) ∪ <a>names</a>(AT'), ATM' ) <br /> where ATM' = <br />
							{ <a>DEFAULT</a> => <a>Tree-UNION</a>(<a>defaultPart</a>(AT),
								<a>defaultPart</a>(AT')) } ∪ <br /> { n => <a>content</a>(n, AT) | n
							in <a>names</a>(AT) - <a>names</a>(AT')} ∪ <br /> { n = >
							<a>content</a>(n, AT') | n in <a>names</a>(AT') - <a>names</a>(AT)} ∪
							<br /> { n => <a>Tree-UNION</a>( <a>content</a>(n, AT),
							<a>content</a>(n, AT')) | n in <a>names</a>(AT) &amp; <a>names</a>(AT')} </li>
						<li>If <a>order</a>(AT') &lt;<a>order</a>(AT) = k, then <br />
							<a>Tree-UNION</a>(AT, AT') = <a>Tree-UNION</a>(AT', AT) =
								Associative-NEW<sub>k</sub>( <a>names</a>(AT) , ATM' ) <br /> where
							ATM' = ATM|<sub><a>names</a>(AT)</sub> &cup; {<a>DEFAULT</a> =>
								<a>Tree-UNION</a>(<a>defaultPart</a>(AT), AT')} </li>
					</ul>
					<p>In the case of a single argument ATS that is a set of <a>associative
							trees</a> of order k or less, the value is defined inductively as
						follows.</p>
					<ul>
						<li>if <a>order</a>(ast) = 0 for every ast in ATS (i.e. ast is an <a>RDF
								graph</a>), then <a>Tree-UNION</a>(ATS) = ∪ ATS. Note that this
							includes the case ATS = {}, where <a>Tree-UNION</a>(ATS) = {}.</li>
						<li>if <a>order</a>(ast) = k &gt; 0 for every ast in ATS, then <br />
							<a>Tree-UNION</a>(ATS) = Associative-NEW<sub>k</sub>( result-default,
							result-names, result-nameMap ) <br /> where <br /> result-default =
								<a>Tree-UNION</a>({<a>defaultPart</a>(ast) | ast in ATS}) <br />
							result-names = ∪<sub>ast in ATS</sub>
							<a>names</a>(ast), <br /> result-nameMap = { n =>
								<a>Tree-UNION</a>({<a>content</a>(n, ast)|<sub>ast in ATS</sub>}) |
							n in result-names} </li>
						<li> if max({ <a>order</a>(ast)| ast in ATS}) = k &gt; 0, let
								ATS<sub>k</sub> be the subset of ATS containing all members of ATS
							having order k. Then Tree-UNION(ATS) = <a>Tree-UNION</a>(
								<a>Tree-UNION</a>(ATS -ATS<sub>k</sub>),
								<a>Tree-UNION</a>(ATS<sub>k</sub>)) </li>
					</ul>
					<p class="ednote"> It is possible to informally apply the Tree-UNION operation
						to pairs of <a>repositories</a> or <a>stores</a> by first applying a
						forgetful functor that retains all the versions but forgets the order among
						them. However, the result is not a <a>repository</a> or <a>store</a>, but is
						just a <a>associative tree</a>. To truly extend the UNION operation to
							<a>repositories</a> and <a>stores</a> to generate new
							<a>repositories</a> and <a>stores</a>, it would be necessary to mint new
						version names and to specify how versions are ordered and combined when
						necessary e.g. according to timestamps, but timestamps are not mandatory in
						our definitions There is no precedent for such definitions, since the Update
						spec does not define a union operation on Graph Stores. </p>
					<p class="ednote">We do define a special case of "union" for <a>repositories</a>
						that are all members of the same <a>store</a> using the
							<a>Sequential-UNION</a> operation.</p>
				</section>
				<section>
					<h4>Other Basic Operations</h4>
					<p class="ednote">Similarly, the basic operations of Dataset-DIFF and Dataset
						will be extended to <a>k-th order associative trees</a>. The Dataset
						operation will also be extended to <a>k-th order patterns</a>. </p>
				</section>
			</section>
			<section id="def-existing-update">
				<h3>SPARQL Update Operations</h3>
				<section id="def-existing-update-insert-data">
					<h4>Insert Data</h4>
					<p><dfn>Insert Data</dfn> is defined in [[!SPARQL11-Update]] as an Update
						Operation with the following signature:</p>
					<ul>
						<li>On the domain RDF Dataset x IRI, the range is RDF Dataset.</li>
					</ul>
					<p>The semantics of <a>Insert Data</a> is defined in [[!SPARQL11-Update]] as
						follows.</p>
					<p><a>OpInsertData</a>(GS, <em>QuadPattern</em>) = <a>Dataset-UNION</a>(GS,
							<a>Dataset(</a><em>QuadPattern</em>,{},GS,GS))</p>
					<p>where {} is the empty solution mapping,</p>
					<p> GS is an <a>RDF Dataset</a>, and <em>QuadPattern</em> is a ground quad
						pattern. </p>
					<p>The Insert Data operation constructs a new RDF Dataset from an existing RDF
						Dataset by adding triples and quads to it as expressed in the ground
							<em>QuadPattern</em>. Note that Insert Data is functional in that it
						does not actually "change" the input RDF Dataset. Update operations may be
						used to define a Graph Store as a state machine, where the state of a Graph
						Store is an RDF Dataset, and Update Operations take the current state of a
						Graph Store as one of their input arguments, generating a new RDF Dataset
						which then is taken as the new state of the Graph Store. </p>
					<p> We extend the Insert Data operation to <a>k-th order associative trees</a>. </p>
					<ul>
						<li>On the domain <a>k-th order associative trees</a> x <a>k-th order
								associative trees</a>, the range is <a>k-th order associative
								trees</a>.</li>
					</ul>
					<p>The extended semantics of <a>Insert Data</a> is defined as follows.</p>
					<p><dfn>OpInsertData</dfn>(AT, AT') = <a>Tree-UNION</a>(AT, <a>Tree(</a>AT', {},
						AT, AT))</p>
					<p>where {} is the empty solution mapping,</p>
					<p>The function <dfn>Tree(</dfn>) needs to be defined as a generalization of
							<a>Dataset(</a>). The reason that <a>OpInsertData</a> is not defined
						directly as <a>Tree-UNION</a>(AT, AT') is because of the requirement that
						blank nodes be renamed.</p>
				</section>
				<section id="def-existing-update-opcreate">
					<h4>OpCreate</h4>
					<p><dfn>OpCreate</dfn> is defined in [[!SPARQL11-Update]] as an Update Operation
						with the following signature:</p>
					<ul>
						<li>On the domain RDF Dataset x IRI, the range is RDF Dataset.</li>
					</ul>
					<p>The semantics of <a>OpCreate</a> is defined in [[!SPARQL11-Update]] as
						follows.</p>
					<p>Let GS = {DG} union {(iri<sub>i</sub>, G<sub>i</sub>) | 1 ≤ i ≤ n} and
							<a>graphNames</a>(GS) = { iri<sub>i</sub> | 1 ≤ i ≤ n}, then</p>
					<p><a>OpCreate</a>(GS, iri) = GS union {(iri, {})} if iri not in
							<a>graphNames</a>(GS); otherwise, <a>OpCreate</a>(GS, iri) = GS</p>
					<p> where DG and G<sub>i</sub> are graphs, iri and iri<sub>i</sub> are IRIs. </p>
					<p>The OpCreate operation constructs a new RDF Dataset from an existing RDF
						Dataset by adding an empty named graph to it with a specified IRI as name,
						provided it does not already contain a named graph of the specified name.
						Note that OpCreate is functional in that it does not actually "change" the
						input RDF Dataset. Update operations may be used to define a Graph Store as
						a state machine, where the state of a Graph Store is an RDF Dataset, and
						Update Operations take the current state of a Graph Store as input,
						generating a new RDF Dataset which then is taken as the new state of the
						Graph Store. </p>
					<p> We extend the OpCreate operation to <a>k-th order associative trees</a>.
						Also, the names are extended from IRIs to also allow blank node names. </p>
					<ul>
						<li>On the domain <a>k-th Order associative tree</a> x I ∪ RDF-B, the range
							is max(k, 1)-th Order <a>associative trees</a>.</li>
						<li>On the domain <a>k-th Order associative tree</a> x I ∪ RDF-B x Int, the
							range is <a>associative trees</a></li>
					</ul>
					<p>The extended semantics of <a>OpCreate</a> is defined as follows.</p>
					<ul>
						<li><a>OpCreate</a>(AT, n) = <a>OpCreate</a>(AT, n, max(<a>order</a>(AT),
							1)).</li>
						<li>If n is in <a>n</a>(AT), and k =<a>order</a>(AT), then
							<a>OpCreate</a>(AT, n, k) = AT.</li>
						<li>If k &gt;<a>order</a>(AT), then <a>OpCreate</a>(AT, n, k) =
								Associative-NEW<sub>k</sub>(AT, {n}, {n => {}})</li>
						<li>If k =<a>order</a>(AT) and n is not in <a>names</a>(AT), then
								<a>OpCreate</a>(AT, n, k) =
								Associative-NEW<sub>k</sub>(<a>defaultPart</a>(AT), <a>names</a>(AT)
							∪ {n}, <a>nameMap</a>(AT) ∪ {n => {}}). </li>
						<li>If k &lt;<a>order</a>(AT) = k', then <a>OpCreate</a>(AT, n, k) =
								Associative-NEW<sub>k'</sub>(
							<a>OpCreate</a>(<a>defaultPart</a>(AT), n, k), <a>names</a>(AT),
								<a>nameMap</a>(AT) ) )</li>
					</ul>
					<p class="ednote">The semantics needs to rewritten to accommodate the revised
						signature of <a>Associative-NEW</a>.</p>
				</section>
				<section>
					<h4>Other Update Operations</h4>
					<p class="ednote">Similarly, the Update Operations of SPARQL Update can be
						extended to <a>k-th order associative trees</a>, making use of the extended
						basic operations. </p>
				</section>
			</section>
			<section id="def-new-apply-operation">
				<h4>Apply Operation</h4>
				<p class="ednote">The above extensions only allow management, e.g. creation of a new
					"slot", at the top level of a <a>k-th order associative tree</a>. However, it is
					also useful to be able to apply operations at a deeper level within a <a>k-th
						order associative tree</a>. This capability can be enabled with a generic
					operation, called <dfn>Apply</dfn>, which takes a <a>k-th order associative
						tree</a> as first argument, an Operation specification (unary function built
					from Operation name and tuple of arguments with a placehoder in one position) as
					second argument, and an optional third argument that is an <a>RDF Name</a>. The
					result would be the result of applying that Operation with the appropriate
					(named or default) (k-1)-th order associative tree replacing the placeholder,
					and then substituting for the (k-1)-th order associative tree with the operation
					result within the original <a>k-th order associative tree</a>. If the name is
					not in the set of database names, then the result would be the original
					associative tree. </p>
				<ul>
					<li>If n is in <a>Ext-DEFAULT</a>(<a>names</a>(AT)), then APPLY(AT, SPM, n) =
								Associative-NEW<sub><a>order</a>(AT)</sub>( <a>names</a>(AT),
							<a>nameMap</a>(AT)|<sub>- n</sub> &cup; { n => SPM(<a>content</a>(n,
						AT))} ) </li>
					<li>Otherwise, APPLY(AT, SPM, n) = AT.</li>
					<li>APPLY(AT, SPM) = APPLY(AT, SPM, <a>DEFAULT</a>)</li>
				</ul>
			</section>
			<section id="def-new-revise-operation">
				<h4>Revise Operation</h4>
				<p>Update Operations as defined in SPARQL Update, and here extended, are not
					directly applicable to <a>repositories</a> and <a>stores</a>. In order to enable
					them, we define a Revise operation, that takes as input a <a>repository</a>
					(with a terminal version) as first argument, an Update Operation specification
					as second argument and a name (IRI or blank node) as third argument. The result
					is a new <a>repository</a> that has an additional <a>version</a>, that being the
					result of applying the Update Operation to the terminal <a>version</a> of the
					input repository, and making that the new terminal version, using the specified
					name as the version name. </p>
				<p>The Revise Operation may be extended to <a>stores</a> in the obvious fashion.
					However, this only allows manipulation of the version sequence of the store. To
					enable direct manipulation of the version sequence of repositories within the
					store, we extend the <a>Apply</a> Operation, defined above for <a>k-th order
						associative trees</a> and Update Operation specifications, to <a>stores</a>
					and Revise Operation specifications on repositories (only for unnested Revise). </p>
				<p>Application of a Revise operation to a structure without a terminal version is
					undefined. </p>
			</section>
			<!--
		  <section>
		  <p class="ednote">Options for extending Update Operations to the Store/Repository model are:
		  </p>
		  <ol>
		    <li>Follow the functional approach by defining functions that act on the "state" of a Store, 
			(defined in terms of the Repositories, named or default, that it owns), 
			producing a new state.
			This state then presumably becomes the current state of the mutable Store, just like in the SPARQL UPDATE spec,
			but the mutability of a Store is not addressed explicitly.
			However, the mutability of Repositories is explicitly addressed, 
			these being the objects that make up the state of a Store.
			</li>
			<li>Handle the mutability of Stores explicitly by defining mutator methods on Store "objects".
			</li>
			<li>Take a full-blown functional approach by hiding all mutability.
			The "state" of a Store is then not expressed in terms of Repositories, but in terms of the "states"
			of its Repositories.
			The state of a Repository is an RDF Dataset, in parallel to the state of a Graph Store being an RDF graph.
			</li>
		  </ol>
		  
		  <p>Here is what the first option would look like:
          </p>
		  <p>
		  We further extend the OpCreate operation to <a>k-th Order Stores</a>.
		  </p>
		  <ul>
		    <li>On the domain <a>k-th Order Store</a> x I ∪ RDF-B, the range is <a>k-th Order Store</a>.</li>
		  </ul>
		  <p>The extended semantics of <a>OpCreate</a> is defined as follows.</p> 
		  <p>Let S<sup>k</sup> = {R<sup>k</sup>} ∪ 
		  {(name<sub>i</sub>, R<sup>k</sup><sub>i</sub>) | 1 ≤ i ≤ n} and 
		  @@@datasetNames(R<sup>k</sup>) = { name<sub>i</sub> | 1 ≤ i ≤ n}, then</p>
		  <p><a>OpCreate</a>(S<sup>k</sup>, name) = S<sup>k</sup> ∪ {(name, R<sup>k</sup><sub>0</sub>)} 
		  if name not in @@@datasetNames(S<sup>k</sup>); 
		  otherwise, <a>OpCreate</a>(S<sup>k</sup>, name) = S<sup>k</sup></p>
		  <p>
		  where S<sup>k</sup> is a <a>k-th Order Store</a>, 
		  R<sup>k</sup><sub>i</sub> are <a>k-th Order Repositories</a>, 
		  name and name<sub>i</sub> are IRIs or blank nodes (I ∪ RDF-B)
		  and  R<sup>k</sup><sub>0</sub> is the empty <a>k-th Order Repository</a>.
		  </p>
		  -->
			<!--
		  <p>We extend the syntax of OpCreate to include the following additional signature:</p>
		  <ul>
		    <li>On the domain StoreState x IRI, the range is StoreState.</li>
		  </ul>
		  <p>The semantics of <a>OpCreate</a> on the domain extension is defined as follows.</p> 
		  <p>Let SS = {DR} union {NR<sub>i</sub> | 1 ≤ i ≤ n} and <a>repositoryNames</a>(SS) = { <a>name</a>(NR<sub>i</sub>) | 1 ≤ i ≤ n}, then</p>
		  <p><a>OpCreate</a>(SS, iri) = SS union { NamedRepository(iri, R0)} if iri not in <a>repositoryNames</a>(SS); 
		  otherwise, <a>OpCreate</a>(SS, iri) = SS</p>
		  <p>
		  where DR is a repository, NR<sub>i</sub> are named repositories, iri is an IRI, and 
		  R0 is the "empty repository".
		  </p>		  
		  <p>Here is what the second option would look like:
          </p>
		  <p>
		  The corresponding "create" operation for <a>Stores</a> is a mutator operation on the mutable Store object.
		  </p>
		  <p><dfn>Store.create(self, iri)</dfn> has domain Store x IRI and is void.
		  </p>
		  <p class="ednote">The semantics of Store.create is to have the side-effect of 
             constructing a new Named Repository object with name iri whose initial content is empty, 
			 that is owned by the Store self.		  
		  </p>
		  <p class="ednote">We must defined the meaning of the "initial content of a (Named) Repository is empty" somewhere,
		  probably as a note to the definition of (Named) Repository.
		  </p>
		  <p class="ednote">Is "owned" the property term to use for the relationship between a Named Repository and
		  its parent Store?
		  </p>
		  <p>Here is what the third option would look like:
          </p>
		  <p>We extend the syntax of OpCreate to include the following additional signature:</p>
		  <ul>
		    <li>On the domain StoreState x IRI, the range is StoreState.</li>
		  </ul>
		  <p>The semantics of <a>OpCreate</a> on the domain extension is defined as follows.</p> 
		  <p>Let SS = {DD} union {(iri<sub>i</sub>, D<sub>i</sub>) | 1 ≤ i ≤ n} and 
		  <a>repositoryNames</a>(SS) = { iri<sub>i</sub> | 1 ≤ i ≤ n}, then</p>
		  <p><a>OpCreate</a>(SS, iri) = SS union { (iri, {})} if iri not in <a>repositoryNames</a>(SS); 
		  otherwise, <a>OpCreate</a>(SS, iri) = SS</p>
		  <p>
		  where DD and D<sub>i</sub> are RDF Datasets, iri and iri<sub>i</sub> are IRIs.
		  </p>
         </section>
		-->
			<!--
		<section id="def-existing-update-operator">
          <h4>Operator</h4>
		  <p><dfn>Operator</dfn> is defined in [[!SPARQL11-Update]] as an Update Operation with the following signatures:</p>
		  <ul>
		    <li>On the domain X x Y, the range is Z.</li>
			<li>On the domain X x U, the range is V.</li>
		  </ul>	
		  <p class="ednote">The semantics of <a>Operator</a> is defined in [[!SPARQL11-Update]] to be (semantics)
		  </p>
    	</section>
		<section id="def-extension-of-existing-update-operator">
          <h4>Operator</h4>
		  <p><dfn>Operator</dfn> is defined in [[!SPARQL11-Update]] as a (supertype) with the following signatures:</p>
		  <ul>
		    <li>On the domain X x Y, the range is Z.</li>
			<li>On the domain X x U, the range is V.</li>
		  </ul>
		  <p>We extend the syntax of Operator to include the following additional signatures:</p>
		  <ul>
		    <li>On the domain X x Y, the range is Z.</li>
			<li>On the domain X x U, the range is V.</li>
		  </ul>
		  <p class="ednote">The semantics of <a>Operator</a> is defined in [[!SPARQL11-Update]] to be (semantics)
		  </p>
		  <p class="ednote">The intended semantics of <a>Operator</a> on the extended signature is (semantics)
		  </p>
		</section>
		<section id="def-new-operator">
          <h4>Operator</h4>
		  <p>A <dfn>Operator</dfn> is a (supertype) where (specialization)</a>.
		  </p>	
		  <p class="ednote">The intended semantics of <a>Operator</a> is (semantics)
		  </p>
		</section>
		-->
		</section>
		<section id="examples">
			<h2>Examples</h2>
			<p class="ednote">These examples have been harmonized with the latest terminology and
				concepts.</p>
			<section id="fhir-hr-stream-example">
				<h3>FHIR Heartrate RDF Stream Example</h3>
				<section id="fhir-hr-graph-example">
					<h4>FHIR Heartrate Unit Graphs</h4>
					<aside class="example" title="FHIR Observations Without Timestamps">
						<p>The concept of <a>StoreTransformation</a>-based operations is that graphs
							are treated as indivisible units. Here we define some basic graphs
							describing FHIR observations, but without timestamps. These graphs will
							be used to illustrate the emulation of RDF Streams that transmit this
							observational information in various forms. </p>
						<p>We use a common prefix section for all graphs as follows.</p>
						<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema&gt; .
						</pre>
						<!--
						<p>Let G<sub>1, FHIR-hr</sub> be: </p>
						<pre>
_:b1 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b2 .
	
_:b2 lr:unit "bpm"^^xsd:string ;
		lr:value "50"^^xsd:integer .
</pre>
						<p>G<sub>2, FHIR-hr</sub> be:. </p>
						<pre>
_:b4 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b5 .
	
_:b5 lr:unit "bpm"^^xsd:string ;
		lr:value "53"^^xsd:integer .
</pre>
						<p>G<sub>3, FHIR-hr</sub> be: </p>
						<pre>
_:b7 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b8 .
	
_:b8 lr:unit "bpm"^^xsd:string ;
		lr:value "48"^^xsd:integer .
</pre>
-->
						Given the graphs <table border="0" style="">
							<tr>
								<td>G<sub>1, FHIR-hr</sub></td>
								<td><pre style="margin-top:0; margin-bottom:0">_:b1 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b2 .
	
_:b2 lr:unit "bpm"^^xsd:string ;
		lr:value "50"^^xsd:integer .
</pre></td>
							</tr>
							<tr>
								<td>G<sub>2, FHIR-hr</sub></td>
								<td><pre style="margin-top:0; margin-bottom:0">_:b4 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b5 .
	
_:b5 lr:unit "bpm"^^xsd:string ;
		lr:value "53"^^xsd:integer .
</pre></td>
							</tr>
							<tr>
								<td>G<sub>3, FHIR-hr</sub></td>
								<td><pre style="margin-top:0; margin-bottom:0">_:b7 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b8 .
	
_:b8 lr:unit "bpm"^^xsd:string ;
		lr:value "48"^^xsd:integer .
</pre></td>
							</tr>
						</table>
					</aside>
					<p>We also define some unit graphs holding timestamp triples.</p>
					<aside class="example" title="FHIR effectiveDateTime Timestamp">
						<p>Let TS<sub>1, FHIR-hr</sub> be a graph containing a triple using the
							predicate <code>obs:effectiveDateTime</code>. Because this predicate
							meets the requirements for an <a>RDF Stream timestamp predicate</a>,
							then we may use the triple in this graph as a timestamp triple in the
							emulation of a <a>timestamped graph</a>.</p>
						<pre>
_:b1 obs:effectiveDateTime 
    "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp
</pre>
						<p>Similarly, we define TS<sub>2, FHIR-hr</sub></p>
						<pre>
_:b4 obs:effectiveDateTime 
    "2015-01-01T12:01:00Z"^^xsd:dateTimeStamp
</pre>
						<p> and TS<sub>3, FHIR-hr</sub></p>
						<pre>
_:b7 obs:effectiveDateTime 
    "2015-01-01T12:02:00Z"^^xsd:dateTimeStamp
</pre>
					</aside>
				</section>
				<section>
					<h4>Repository of FHIR Heartrate Observations</h4>
					<p>We now construct a repository of observations where the graphs G<sub>i,
							FHIR-hr</sub> are the version contents.</p>
					<aside class="example" title="Repository of FHIR Heartrate Observations">
						<p>We first show the usage of the <a>Versioned-NEW<sub>k</sub></a>
							constructor to build a repository.</p>
						<p><dfn>Repo<sub>FHIR-hr</sub></dfn> =
								<a>Versioned-NEW</a><sub>1</sub>(VI<sub>FHIR-hr</sub>,
								M<sub>FHIR-hr</sub>)</p>
						<p>where</p>
						<p>VI<sub>FHIR-hr</sub> = <a>Chain</a>([_:fhir-hr-g1, _:fhir-hr-g2,
							_:fhir-hr-g3])</p>
						<p>is the ordered set of repository versions names, and</p>
						<p>M<sub>FHIR-hr</sub> = {_:fhir-hr-g1 => G<sub>1, FHIR-hr</sub>,
							_:fhir-hr-g2 => G<sub>2, FHIR-hr</sub>, _:fhir-hr-g3 => G<sub>3,
								FHIR-hr</sub> }</p>
						<p>is the mapping from version names to version content.</p>
						<p class="ednote">Need to define <dfn>Chain</dfn> as a function that takes a
							sequence with distinct elements to a totally-ordered set.</p>
						<p class="note">This repository is constructed as a first-order data
							structure, which is possible because the version contents are just
							graphs (zeroth order), rather than higher-order structures. We could in
							fact choose any repository order higher than 1 as well.</p>
					</aside>
					<p>We can also use basic operations to build this finite repository, as
						follows.</p>
					<aside class="example" title="Repository Built with Basic Operations">
						<p>we first initialize the repository with <a>Repository-INITIAL</a></p>
						<p class="ednote">We need to define this basic operation as
								<dfn>Repository-INITIAL</dfn><sub>k</sub>(ATD, name, ATN) =
									<a>Versioned-NEW<sub>k</sub></a>([{name}, {}], {name => ATN,
								<a>DEFAULT</a> => ATD})</p>
						<p><dfn>Repo<sub>1, FHIR-hr</sub></dfn> =
								<a>Repository-INITIAL</a><sub>1</sub>({}, _:fhir-hr-g1, G<sub>1,
								FHIR-hr</sub>) </p>
						<p>Then we use <a>Append2Repository</a><sub>1</sub> twice to add the later
							versions,</p>
						<p><dfn>Repo<sub>2, FHIR-hr</sub></dfn> =
								<a>Append2Repository</a><sub>1</sub>(<a>Repo<sub>1,
								FHIR-hr</sub></a>, _:fhir-hr-g2, G<sub>2, FHIR-hr</sub>) </p>
						<p><a>Repo<sub>FHIR-hr</sub></a> =
									<a>Append2Repository</a><sub>1</sub>(<a>Repo<sub>2,
									FHIR-hr</sub></a>, _:fhir-hr-g3, G<sub>3, FHIR-hr</sub>) </p>
					</aside>
					<aside class="example" title="Table of Query Results From Repository">
						<p>A first-order repository can be thought of as like an RDF Dataset, but
							with a total order among the names of named graphs. The following table
							illustrates a list of solution mappings for the <code>select *</code>
							query of the <dfn>identity pattern for first-order
							repositories</dfn></p>
						<pre>
{ version ?v {?s ?p ?o} } union {ASSOC {?s ?p ?o}}</pre>
						<p>applied to the first-order repository <a>Repo<sub>FHIR-hr</sub></a> where
							the final column holds an index that indicates relative order among the
							solution mappings. </p>
						<div>
							<table>
								<thead>
									<tr>
										<td>?s</td>
										<td>?p</td>
										<td>?o</td>
										<td>?v</td>
										<td>i</td>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>_:b1</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g1</td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g1</td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g1</td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g1</td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:valueQuantity</td>
										<td>_:b2</td>
										<td>_:fhir-hr-g1</td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g1</td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g1</td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g2</td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g2</td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g2</td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g2</td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:valueQuantity</td>
										<td>_:b5</td>
										<td>_:fhir-hr-g2</td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g2</td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g2</td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g3</td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g3</td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g3</td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g3</td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:valueQuantity</td>
										<td>_:b8</td>
										<td>_:fhir-hr-g3</td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g3</td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g3</td>
										<td>3</td>
									</tr>
								</tbody>
							</table>
						</div>
					</aside>
				</section>
				<section>
					<h4>Store of FHIR Heartrate Observations</h4>
					<p>The repository that was built in the previous example holds the atemporal
						information about the observations and their relative order, but does not
						contain the temporal information from the triples that use the
						obs:effectiveDateTime predicate. We will now embed the repository of
						atemporal observations into a second-order store, where the temporal
						statement appears in the default part of the store version contents. </p>
					<aside class="example"
						title="Store holding an RDF Stream of FHIR Heartrate Observations">
						<p>We first use the <a>Store-NEW<sub>k</sub></a> constructor as follows.</p>
						<p><dfn>Store<sub>FHIR-hr</sub></dfn> = <a>Store-NEW</a><sub>2</sub>(RN, R,
							SI, NM) where</p>
						<ul>
							<li>RN = {_:fhir-hr} (the set of repository names)</li>
							<li>R<sub>_:fhir-hr</sub> = <a>Repo<sub>FHIR-hr</sub></a> (the "named"
								repository, containing the atemporal part of the timestamped
								graphs)</li>
							<li>R<sub><a>DEFAULT</a></sub> = <a>Repo<sub>FHIR-ts</sub></a> (the
								default repository, containing the timestamp triples of the
								timestamped graphs)</li>
							<li>SI = <a>Chain</a>([_:strst1, _:strst2, _:strst3]) (the ordered set
								of store version names)</li>
							<li>NM<sub>_:fhir-hr</sub> = {_:strst1 => _:fhir-hr-g1, _:strst2 =>
								_:fhir-hr-g2, _:strst3 => _:fhir-hr-g3} (the mapping from store
								version names to repository version names, for the "named"
								repository)</li>
							<li>NM<sub><a>DEFAULT</a></sub> = {_:strst1 => _:fhir-hr-ts1, _:strst2
								=> _:fhir-hr-ts2, _:strst3 => _:fhir-hr-ts3} (the mapping from store
								version names to repository version names, for the default
								repository)</li>
						</ul>
						<p>and where</p>
						<p><dfn>Repo<sub>FHIR-ts</sub></dfn> =
									<a>Append2Repository</a><sub>1</sub>(<a>Repo<sub>2,
									FHIR-ts</sub></a>, _:fhir-hr-ts3, TS<sub>3, FHIR-hr</sub>)</p>
						<p><dfn>Repo<sub>2, FHIR-ts</sub></dfn> = =
								<a>Append2Repository</a><sub>1</sub>(<a>Repo<sub>1,
								FHIR-ts</sub></a>, _:fhir-hr-ts2, TS<sub>2, FHIR-hr</sub>)</p>
						<p><dfn>Repo<sub>1, FHIR-ts</sub></dfn> = =
								<a>Repository-INITIAL</a><sub>1</sub>(_:fhir-hr-ts1, TS<sub>1,
								FHIR-hr</sub>)</p>
					</aside>
					<aside class="example" title="Table of Query Results From Store">
						<p>The following table illustrates a list of solution mappings for the
								<code>select *</code> query of the <dfn>identity pattern for
								second-order stores</dfn></p>
						<pre>
{ version ?sv {graph ?r {?s ?p ?o} } union {DEFAULT {?s ?p ?o} } } union
{repo ?r {version ?rv {?s ?p ?o} } union {ASSOC {?s ?p ?o} } } union
{DEFAULT {version ?rv {?s ?p ?o} } union {ASSOC {?s ?p ?o} } }
</pre>
						<p>applied to the second-order store <a>Store<sub>FHIR-hr</sub></a>, where
							the final three columns holds indices that indicates relative order
							among the solution mappings. </p>
						<div>
							<table>
								<thead>
									<tr>
										<td>?s</td>
										<td>?p</td>
										<td>?o</td>
										<td>?rv</td>
										<td>?r</td>
										<td>?sv</td>
										<td>i</td>
										<td>j</td>
										<td>k</td>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>_:b1</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:00:00Z"^^xsd:dateTimeStamp></td>
										<td>_:def-g1</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:00:00Z"^^xsd:dateTimeStamp></td>
										<td></td>
										<td></td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:valueQuantity</td>
										<td>_:b2</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:valueQuantity</td>
										<td>_:b2</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:01:00Z"^^xsd:dateTimeStamp></td>
										<td>_:def-g2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:01:00Z"^^xsd:dateTimeStamp></td>
										<td></td>
										<td></td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:valueQuantity</td>
										<td>_:b5</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:valueQuantity</td>
										<td>_:b5</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:02:00Z"^^xsd:dateTimeStamp></td>
										<td>_:def-g3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:02:00Z"^^xsd:dateTimeStamp></td>
										<td></td>
										<td></td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:valueQuantity</td>
										<td>_:b8</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:valueQuantity</td>
										<td>_:b8</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td></td>
										<td>_:fhir-hr</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
								</tbody>
							</table>
						</div>
					</aside>
					<aside class="ednote">
						<p>Because of the redundancy that appears in the above table, a better
							identity pattern for second order stores is developed incrementally
							below. First we consider the following pattern.</p>
						<pre>
{DEFAULT {version ?rv {?s ?p ?o} } union {ASSOC {?s ?p ?o} } } union
{repo ?r {version ?rv {?s ?p ?o} } union {ASSOC {?s ?p ?o} } } union
{ version ?sv {DEFAULT {?sx ?px ?ox} } . 	 
   DEFAULT {version ?rv {?sx ?px ?ox} }  } union
{ version ?sv {graph ?r {?sx ?px ?ox} } . 	 
   repo ?r {version ?rv {?sx ?px ?ox} }  }
</pre>
						<p>Applied with SELECT ?s ?p ?o ?rv ?r ?sv to
							<a>Store<sub>FHIR-hr</sub></a>, the following solution mappings match
							this pattern.</p>
						<div>
							<table>
								<thead>
									<tr>
										<td>?s</td>
										<td>?p</td>
										<td>?o</td>
										<td>?rv</td>
										<td>?r</td>
										<td>?sv</td>
										<td>i</td>
										<td>j</td>
										<td>k</td>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>_:b1</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:00:00Z"^^xsd:dateTimeStamp></td>
										<td>_:def-g1</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:def-g1</td>
										<td></td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:valueQuantity</td>
										<td>_:b2</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:01:00Z"^^xsd:dateTimeStamp></td>
										<td>_:def-g2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:def-g2</td>
										<td></td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:valueQuantity</td>
										<td>_:b5</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:02:00Z"^^xsd:dateTimeStamp></td>
										<td>_:def-g3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:def-g3</td>
										<td></td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:valueQuantity</td>
										<td>_:b8</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:unit</td>
										<td>"bpm"^^xsd:string</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:value</td>
										<td>"50"^^xsd:integer</td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
								</tbody>
							</table>
						</div>
					</aside>
					<p class="note">This approach for representing an RDF stream of graphs within a
						second-order store can be extended so that multiple streams are held within
						the same store, under certain conditions. The timestamp triples for a
						particular store version are all held in the same graph, within the default
						repository of the store. If two streams use the same name for the named
						graph in their respective timestamped graphs and these elements happen to
						coincide with respect to the store (i.e. belong to the same store version),
						then it will not be possible to distinguish which timestamp triple goes with
						which stream. Thus, there is information lost with this representation
						system in this particular case.</p>
					<p class="ednote">The conflict described in the previous note could be avoided
						by using a third-order store. In the example treated here, the named graph
						of the timestamped graph is empty, and this is what allows us to use a
						second-order store for the representation. But this is an atypical case. In
						general, a timestamped graph will have a non-empty named graph, and thus it
						is necessary to use a third-order store for its representation. In a
						third-order store, there would be an option to attach the repository name to
						the timestamp triple. This would capture the missing information as to which
						triple goes with which stream.</p>
					<aside class="ednote">
						<p>There is a problem with the above attempt at a "store identity pattern"
							presented in the previous note when applied to a general RDF stream.
							Extra mappings may appear associating store and repository versions if a
							triple appears in more than one stream element. Consider this stream
							representation:</p>
						<div>
							<table>
								<thead>
									<tr>
										<td>?s</td>
										<td>?p</td>
										<td>?o</td>
										<td>?rv</td>
										<td>?r</td>
										<td>?sv</td>
										<td>i</td>
										<td>j</td>
										<td>k</td>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>_:b1</td>
										<td>prov:generatedAtDateTime</td>
										<td>"2015-01-01T12:00:00Z"^^xsd:dateTimeStamp></td>
										<td>_:def-g1</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:def-g1</td>
										<td></td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>ex:p</td>
										<td>ex:o1</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>ex:some</td>
										<td>ex:other</td>
										<td>ex:triple</td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>prov:generatedAtDateTime</td>
										<td>"2015-01-01T12:01:00Z"^^xsd:dateTimeStamp></td>
										<td>_:def-g2</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:def-g2</td>
										<td></td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>ex:p</td>
										<td>ex:o2</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>ex:some</td>
										<td>ex:other</td>
										<td>ex:triple</td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
								</tbody>
							</table>
						</div>
						<p>For such a store, there would be additional matches for the following
							part of the pattern:</p>
						<pre>
{ version ?sv {graph ?r {?sx ?px ?ox} } . 	 
   repo ?r {version ?rv {?sx ?px ?ox} }  }
</pre>
						<p>with the matches as follow.</p>
						<div>
							<table>
								<thead>
									<tr>
										<td>?s</td>
										<td>?p</td>
										<td>?o</td>
										<td>?rv</td>
										<td>?r</td>
										<td>?sv</td>
										<td>i</td>
										<td>j</td>
										<td>k</td>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
								</tbody>
							</table>
						</div><p>However, we don't want these matches to be considered a solution
							mapping unless <em>all</em> of the triples in the repository version are
							also in the store version.</p>
						<p>So, we need a pattern that checks whether all of the triples in the store
							version that are associated with a particular repository match the
							triples in a particular version of that repository. This can be done
							with aggregation as follows.</p>
					</aside>
					<aside class="example"
						title="Pattern for Matching All Triples in a Repository Version">
						<p>We first consider the default repository of the store. We require that
							the count of triples that occur in both a repository version and a store
							version is equal to the count of the triples in the repository
							version.</p>
						<pre>
SELECT ?sv ?rv
WHERE {
  {
	SELECT (COUNT(CONCAT(?s, ?p, ?o)) AS ?count) ?sv ?rv
	WHERE {
	  version ?sv {DEFAULT {?sx ?px ?ox} } . 	 
	  DEFAULT {version ?rv {?sx ?px ?ox} }  
	} GROUP BY ?sv ?rv
  }
  {
	SELECT (COUNT(CONCAT(?s, ?p, ?o)) AS ?count) ?rv
	WHERE {
	  DEFAULT {version ?rv {?sx ?px ?ox} }
	} GROUP BY ?rv
  }
}
</pre>
						<p>Similarly we may modify the pattern for matching store versions to
							non-default repository versions.</p>
						<pre>
SELECT ?sv?rp ?rv
WHERE {
  {
	SELECT (COUNT(CONCAT(?s, ?p, ?o)) AS ?count) ?sv ?rp ?rv
	WHERE {
	  version ?sv {?rp {?sx ?px ?ox} } . 	 
	  ?rp {version ?rv {?sx ?px ?ox} } S
	} GROUP BY ?sv ?rp ?rv
  }
  {
	SELECT (COUNT(CONCAT(?s, ?p, ?o)) AS ?count) ?rp ?rv
	WHERE {
	  ?rp {version ?rv {?sx ?px ?ox} } 
	} GROUP BY ?rp ?rv
  }
}
</pre>
					</aside>
					<aside class="example">
						<p>The improved store identity pattern, as described in the previous
							example, will produce only the results shown in the table when applied
							to the FHIR-hr stream represented as a second-order store. However, this
							happens only because there are no stream elements that recur within the
							stream with the exception of differing timestamp triple. For example,
							suppose that the repository holding that stream had been defined exactly
							as above with the exception that the third stream element was a
							repitition of the first stream element except for the value of the
							timestamp. (Admittedly unrealistic in this example, but could reasonably
							occur if the stream is designed to choose from a predefined set of
							observations.)</p>
						<p><a>Repo<sub>FHIR-hr</sub></a> =
									<a>Append2Repository</a><sub>1</sub>(<a>Repo<sub>2,
									FHIR-hr</sub></a>, _:fhir-hr-g3, G<sub>1, FHIR-hr</sub>) </p>
						<p>This problematic case does not arise if there are constraints that forbid
							such recurrence of stream elements, e.g. the graph name of the
							timestamped graph is constrained to only to be used, as a graph name,
							once in each stream.</p>
					</aside>
				</section>
				<section>
					<h4>Second-Order Repository of FHIR Heartrate Observations</h4>
					<p>To resolve the issue of identifying timestamp triples mentioned above, we now
						explore the use of higher-order structures.</p>
					<p>The construction of a second-order repository is similar to what was done
						above. The only difference is the subscript on the constructors or append
						functions that indicates the order.</p>
					<aside class="example"
						title="Second-Order Repository of FHIR Heartrate Observations">
						<p><dfn>Repo<sub>FHIR-hr-2</sub></dfn> =
								<a>Versioned-NEW</a><sub>2</sub>(VI<sub>FHIR-hr</sub>,
								NM<sub>FHIR-hr</sub>)</p>
						<p>where VI<sub>FHIR-hr</sub> and NM<sub>FHIR-hr</sub> are the same as
							before.</p>
					</aside>
					<aside class="example"
						title="Second-Order Repository Built with Basic Operations">
						<p><dfn>Repo<sub>1, FHIR-hr-2</sub></dfn> =
								<a>Repository-INITIAL</a><sub>2</sub>({}, _:fhir-hr-g1, G<sub>1,
								FHIR-hr</sub>) </p>
						<p><dfn>Repo<sub>2, FHIR-hr-2</sub></dfn> =
								<a>Append2Repository</a><sub>2</sub>(<a>Repo<sub>1,
								FHIR-hr-2</sub></a>, _:fhir-hr-g2, G<sub>2, FHIR-hr</sub>) </p>
						<p><a>Repo<sub>FHIR-hr-2</sub></a> =
									<a>Append2Repository</a><sub>2</sub>(<a>Repo<sub>2,
									FHIR-hr-2</sub></a>, _:fhir-hr-g3, G<sub>3, FHIR-hr</sub>) </p>
					</aside>
				</section>
				<section>
					<h4>Third-Order Store of FHIR Heartrate Observations</h4>
					<p>The primary difference in the third-order store construction that follows is
						that the repository name is attached to each timestamp triple. The timestamp
						triple is still encapsulated within the default repository as in the
						second-order store above. </p>
					<aside class="example"
						title="Third-Order Store holding an RDF Stream of FHIR Heartrate Observations">
						<p><dfn>Store<sub>FHIR-hr-2</sub></dfn> = <a>Store-NEW</a><sub>3</sub>(RN,
							R, SI, NM) where</p>
						<ul>
							<li>RN = {_:fhir-hr} (the set of repository names)</li>
							<li>R<sub>_:fhir-hr</sub> = <a>Repo<sub>FHIR-hr-2</sub></a> (the "named"
								second-order repository, containing the atemporal part of the
								timestamped graphs)</li>
							<li>R<sub><a>DEFAULT</a></sub> = <a>Repo<sub>FHIR-ts-2</sub></a> (the
								default second-order repository, containing the timestamp triples of
								the timestamped graphs, "named" with the repository name it is
								associated with.</li>
							<li>SI = <a>Chain</a>([_:strst1, _:strst2, _:strst3]) (the ordered set
								of store version names)</li>
							<li>NM<sub>_:fhir-hr</sub> = {_:strst1 => _:fhir-hr-g1, _:strst2 =>
								_:fhir-hr-g2, _:strst3 => _:fhir-hr-g3} (the mapping from store
								version names to repository version names, for the "named"
								repository)</li>
							<li>NM<sub><a>DEFAULT</a></sub> = {_:strst1 => _:fhir-hr-ts1, _:strst2
								=> _:fhir-hr-ts2, _:strst3 => _:fhir-hr-ts3} (the mapping from store
								version names to repository version names, for the default
								repository)</li>
						</ul>
						<p>and where</p>
						<p><dfn>Repo<sub>FHIR-ts-2</sub></dfn> =
								<a>Append2Repository</a><sub>2</sub>(<a>Repo<sub>2,
								FHIR-ts-2</sub></a>, _:fhir-hr-ts3, NTS<sub>3, FHIR-hr</sub>)</p>
						<p><dfn>Repo<sub>2, FHIR-ts-2</sub></dfn> = =
								<a>Append2Repository</a><sub>2</sub>(<a>Repo<sub>1,
								FHIR-ts-2</sub></a>, _:fhir-hr-ts2, NTS<sub>2, FHIR-hr</sub>)</p>
						<p><dfn>Repo<sub>1, FHIR-ts-2</sub></dfn> = =
								<a>Repository-INITIAL</a><sub>2</sub>(_:fhir-hr-ts1, NTS<sub>1,
								FHIR-hr</sub>)</p>
						<p>and</p>
						<p>NTS<sub>1, FHIR-hr</sub> = <a>Solitary-NEW</a><sub>1</sub>( _:fhir-hr-2,
								TS<sub>1, FHIR-hr</sub>)</p>
						<p>NTS<sub>2, FHIR-hr</sub> = <a>Solitary-NEW</a><sub>1</sub>( _:fhir-hr-2,
								TS<sub>2, FHIR-hr</sub>)</p>
						<p>NTS<sub>3, FHIR-hr</sub> = <a>Solitary-NEW</a><sub>1</sub>( _:fhir-hr-2,
								TS<sub>3, FHIR-hr</sub>)</p>
						<p>The third-order store identity pattern is as follows.</p>
						<p class="ednote">This pattern has not been fully checked for syntax
							errors.</p>
						<pre>
SELECT ?s ?p ?o ?g ?rv ?r ?sv
WHERE {
  {
    repo ?r {version ?rv {graph ?g {?s ?p ?o} union {?s ?p ?o}} } union 
            {ASSOC       {graph ?g {?s ?p ?o} union {?s ?p ?o}} } 
  } union
  {
    DEFAULT {version ?rv {graph ?g {?s ?p ?o} union {?s ?p ?o}} } union 
            {ASSOC       {graph ?g {?s ?p ?o} union {?s ?p ?o}} } 
  } union
  {
    {
	  SELECT (COUNT(CONCAT(?sx, ?px, ?ox, ?gx)) AS ?countg) ?sv ?rv
	    WHERE {
	      version ?sv {DEFAULT {graph ?gx {?sx ?px ?ox} } } . 	 
	      DEFAULT {version ?rv {graph ?gx {?sx ?px ?ox} } }  
	    } GROUP BY ?sv ?rv
    } .
    {
      SELECT (COUNT(CONCAT(?sx, ?px, ?ox)) AS ?count) ?sv ?rv
	    WHERE {
	      version ?sv {DEFAULT {DEFAULT {?sx ?px ?ox} } } . 	 
	      DEFAULT {version ?rv {DEFAULT {?sx ?px ?ox} } }  
	    } GROUP BY ?sv ?rv
    } .
    {
      SELECT (COUNT(CONCAT(?sx, ?px, ?ox, ?gx)) AS ?countg) ?rv
	    WHERE {
	        DEFAULT {version ?rv {graph ?gx {?sx ?px ?ox} } }  
	    } GROUP BY ?rv
    } .
    {
	  SELECT (COUNT(CONCAT(?sx, ?px, ?ox)) AS ?count) ?rv
	    WHERE {
	        DEFAULT {version ?rv {DEFAULT {?sx ?px ?ox} } }  
	    } GROUP BY ?rv
    }
  } union
  {
    {
	  SELECT (COUNT(CONCAT(?sx, ?px, ?ox, ?gx)) AS ?countg) ?sv ?r ?rv
	    WHERE {
	      version ?sv {repo ?r  {graph ?gx {?sx ?px ?ox} } } . 	 
	      repo ?r {version ?rv {graph ?gx {?sx ?px ?ox} } }  
	    } GROUP BY ?sv ?r ?rv
    } .
    {
      SELECT (COUNT(CONCAT(?sx, ?px, ?ox)) AS ?count) ?sv ?r ?rv
	    WHERE {
	      version ?sv {dataset ?r {DEFAULT {?sx ?px ?ox} } } . 	 
	      repo ?r {version ?rv {DEFAULT {?sx ?px ?ox} } }  
	    } GROUP BY ?sv ?r ?rv
    } .
    {
      SELECT (COUNT(CONCAT(?sx, ?px, ?ox, ?gx)) AS ?countg)?r ?rv
	    WHERE {
	        repo ?r {version ?rv {graph ?gx {?sx ?px ?ox} } }  
	    } GROUP BY ?r ?rv
    } .
    {
	  SELECT (COUNT(CONCAT(?sx, ?px, ?ox)) AS ?count) ?r ?rv
	    WHERE {
	        DEFAULT {version ?rv {DEFAULT {?sx ?px ?ox} } }  
	    } GROUP BY ?r ?rv
    }
  }
}
</pre>
						<div>
							<table>
								<thead>
									<tr>
										<td>?s</td>
										<td>?p</td>
										<td>?o</td>
										<td>?g</td>
										<td>?rv</td>
										<td>?r</td>
										<td>?sv</td>
										<td>i</td>
										<td>j</td>
										<td>k</td>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>_:b1</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:00:00Z"^^...#dateTimeStamp></td>
										<td>_:fhir-hr-2</td>
										<td>_:fhir-hr-ts1</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-ts1</td>
										<td></td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:valueQuantity</td>
										<td>_:b2</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:unit</td>
										<td>"bpm"^^&lt;http://...#string&gt;</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:value</td>
										<td>"50"^^&lt;http://...#integer&gt;</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-2</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:01:00Z"^^...#dateTimeStamp></td>
										<td>_:fhir-hr-2</td>
										<td>_:fhir-hr-ts2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-ts2</td>
										<td></td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:valueQuantity</td>
										<td>_:b5</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:unit</td>
										<td>"bpm"^^&lt;http://...#string&gt;</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:value</td>
										<td>"50"^^&lt;http://...#integer&gt;</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-2</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:02:00Z"^^...#dateTimeStamp></td>
										<td> _:fhir-hr-2</td>
										<td>_:fhir-hr-ts3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-ts3</td>
										<td></td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:valueQuantity</td>
										<td>_:b8</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:unit</td>
										<td>"bpm"^^&lt;http://...#string&gt;</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:value</td>
										<td>"50"^^&lt;http://...#integer&gt;</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-2</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-2</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
								</tbody>
							</table>
						</div>
					</aside>
				</section>
				<section>
					<h4>Another Approach Using A Third-Order Store for an RDF Stream of FHIR
						Heartrate Observations</h4>
					<p>In this example, we develop another approach to identifying the timestamp
						triple. This approach is only applicable to RDF streams that have the
						following characeristic: the predicate that appears in the timestamp triple
						is not used in any other triple of the default graph that has the subject
						being the name of the named graph in that timestamped graph.</p>
					<p>In this case, we include the timestamp triple in the timestamped graph. Then
						in the default graph of the store version content, we have a structural
						triple that identifies the timestamp predicate used at that version for each
						repository.</p>
					<aside class="example"
						title="Third-Order Store holding an RDF Stream of FHIR Heartrate Observations - Alternate">
						<p><dfn>Store<sub>FHIR-hr-3</sub></dfn> = <a>Store-NEW</a><sub>3</sub>(RN,
							R, SI, NM) where</p>
						<ul>
							<li>RN = {_:fhir-hr} (the set of repository names)</li>
							<li>R<sub>_:fhir-hr</sub> = <a>Repo<sub>FHIR-hr-3</sub></a> (the "named"
								second-order repository, containing the entire timestamped
								graphs)</li>
							<li>R<sub><a>DEFAULT</a></sub> = <a>Repo<sub>FHIR-ts-2</sub></a> (the
								default second-order repository, containing the assertion of the
								timestamp predicate for each repository.</li>
							<li>SI = <a>Chain</a>([_:strst1, _:strst2, _:strst3]) (the ordered set
								of store version names)</li>
							<li>NM<sub>_:fhir-hr</sub> = {_:strst1 => _:fhir-hr-g1, _:strst2 =>
								_:fhir-hr-g2, _:strst3 => _:fhir-hr-g3} (the mapping from store
								version names to repository version names, for the "named"
								repository)</li>
							<li>NM<sub>DEFAULT</sub> = {_:strst1 => _:fhir-hr-ts1, _:strst2 =>
								_:fhir-hr-ts2, _:strst3 => _:fhir-hr-ts3} (the mapping from store
								version names to repository version names, for the default
								repository)</li>
						</ul>
						<p>and where G'<sub>i, FHIR-hr</sub> = G<sub>i, FHIR-hr</sub> &cup;
								TS<sub>i, FHIR-hr</sub>, i = 1, 2, 3</p>
						<p><dfn>Repo<sub>1, FHIR-hr-3</sub></dfn> =
								<a>Repository-INITIAL</a><sub>3</sub>({}, _:fhir-hr-g1, G'<sub>1,
								FHIR-hr</sub>) </p>
						<p><dfn>Repo<sub>2, FHIR-hr-3</sub></dfn> =
								<a>Append2Repository</a><sub>3</sub>(<a>Repo<sub>1,
								FHIR-hr-3</sub></a>, _:fhir-hr-g2, G'<sub>2, FHIR-hr</sub>) </p>
						<p><dfn>Repo<sub>FHIR-hr-3</sub></dfn> =
								<a>Append2Repository</a><sub>3</sub>(<a>Repo<sub>2,
								FHIR-hr-3</sub></a>, _:fhir-hr-g3, G'<sub>3, FHIR-hr</sub>) </p>
						<p>as well as</p>
						<p><dfn>Repo<sub>FHIR-ts-3</sub></dfn> =
								<a>Append2Repository</a><sub>2</sub>(<a>Repo<sub>2,
								FHIR-ts-3</sub></a>, _:fhir-hr-ts3, TSP<sub>3, FHIR-hr</sub>)</p>
						<p><dfn>Repo<sub>2, FHIR-ts-3</sub></dfn> = =
								<a>Append2Repository</a><sub>2</sub>(<a>Repo<sub>1,
								FHIR-ts-3</sub></a>, _:fhir-hr-ts2, TSP<sub>2, FHIR-hr</sub>)</p>
						<p><dfn>Repo<sub>1, FHIR-ts-3</sub></dfn> = =
								<a>Repository-INITIAL</a><sub>2</sub>(_:fhir-hr-ts1, TSP<sub>1,
								FHIR-hr</sub>)</p>
						<p>and</p>
						<p>TSP<sub>1, FHIR-hr</sub> is</p>
						<pre>
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .

_:fhir-hr-3 rsp:usesTSPredicate obs:effectiveDateTime 
</pre>
						<p>Similarly, we define TS<sub>2, FHIR-hr</sub></p>
						<pre>
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .

_:fhir-hr-3 rsp:usesTSPredicate obs:effectiveDateTime 
</pre>
						<p> and TSP<sub>3, FHIR-hr</sub></p>
						<pre>
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .

_:fhir-hr-3 rsp:usesTSPredicate obs:effectiveDateTime 
</pre>
						<div>
							<table>
								<thead>
									<tr>
										<td>?s</td>
										<td>?p</td>
										<td>?o</td>
										<td>?g</td>
										<td>?rv</td>
										<td>?r</td>
										<td>?sv</td>
										<td>i</td>
										<td>j</td>
										<td>k</td>
									</tr>
								</thead>
								<tbody>
									<tr>
										<td>_:fhir-hr-3</td>
										<td>rsp:usesTSPredicate</td>
										<td>obs:effectiveDateTime</td>
										<td></td>
										<td>_:fhir-hr-ts1</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-ts1</td>
										<td></td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:00:00Z"^^...#dateTimeStamp></td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b1</td>
										<td>obs:valueQuantity</td>
										<td>_:b2</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:unit</td>
										<td>"bpm"^^&lt;http://...#string&gt;</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b2</td>
										<td>lr:value</td>
										<td>"50"^^&lt;http://...#integer&gt;</td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>1</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g1</td>
										<td>_:fhir-hr-3</td>
										<td>_:strst1</td>
										<td></td>
										<td></td>
										<td>1</td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-ts1</td>
										<td></td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:01:00Z"^^...#dateTimeStamp></td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b4</td>
										<td>obs:valueQuantity</td>
										<td>_:b5</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:unit</td>
										<td>"bpm"^^&lt;http://...#string&gt;</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b5</td>
										<td>lr:value</td>
										<td>"50"^^&lt;http://...#integer&gt;</td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>2</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g2</td>
										<td>_:fhir-hr-3</td>
										<td>_:strst2</td>
										<td></td>
										<td></td>
										<td>2</td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-ts1</td>
										<td></td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:effectiveDateTime</td>
										<td>"2015-01-01T12:02:00Z"^^...#dateTimeStamp></td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>rdf:type</td>
										<td>fhir:Observation</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:code</td>
										<td>sct:36407505</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:device</td>
										<td>lr:sensor1234</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:subject</td>
										<td>lr:patientA</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b7</td>
										<td>obs:valueQuantity</td>
										<td>_:b8</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:unit</td>
										<td>"bpm"^^&lt;http://...#string&gt;</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td>_:b8</td>
										<td>lr:value</td>
										<td>"50"^^&lt;http://...#integer&gt;</td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td></td>
										<td></td>
										<td>3</td>
										<td></td>
									</tr>
									<tr>
										<td></td>
										<td></td>
										<td></td>
										<td></td>
										<td>_:fhir-hr-g3</td>
										<td>_:fhir-hr-3</td>
										<td>_:strst3</td>
										<td></td>
										<td></td>
										<td>3</td>
									</tr>
								</tbody>
							</table>
						</div>
					</aside>
				</section>
			</section>
		</section>
		<section id="examples-old">
			<h2>Old Examples</h2>
			<p class="ednote">These examples have not been harmonized with the latest terminology
				and concepts.</p>
			<section id="fhir-stream-example">
				<h3>FHIR RDF Stream Example</h3>
				<section id="fhir-graph-example">
					<aside class="example" id="ex-fhir-graph" title="FHIR Statements as RDF Graph">
						The following is a representation of an RDF graph in Trig. These statements
						have a sequential (temporal) aspect that is implicitly expressed in
						timestamps of the events of type fhir:Observations. Although the statements
						appear in a particular order within the graph representation, this order is
						not significant to inference. In particualr, the temporal order is not
						directly available through simple entailment. We will show how this same
						data could be handled within some of the new datatypes so that the dynamic
						nature of the statements is accessible through simple entailment. <p>The
							following graph is denoted G<sub>FHIR</sub>.</p>
						<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b1 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:effectiveDateTime "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b2 .
	
_:b2 lr:unit "bpm"^^xsd:string ;
		lr:value "50"^^xsd:integer .

_:b4 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:effectiveDateTime "2015-01-01T12:01:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b5 .
	
_:b5 lr:unit "bpm"^^xsd:string ;
		lr:value "53"^^xsd:integer .

_:b7 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:effectiveDateTime "2015-01-01T12:02:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b8 .
	
_:b8 lr:unit "bpm"^^xsd:string ;
		lr:value "48"^^xsd:integer .
</pre>
						<p>G<sub>FHIR</sub> is the union of three graphs, each fully describing an
							observation. We write:</p>
						<p>G<sub>FHIR</sub> = <a>Tree-UNION</a>(<a>Tree-UNION</a>(G<sub>1,
								FHIR</sub>, G<sub>2, FHIR</sub>), G<sub>3, FHIR</sub>)</p>
						<p>where G<sub>1, FHIR</sub> is: </p>
						<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b1 a fhir:Observation ;
		obs:effectiveDateTime "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b2 .
	
_:b2 lr:unit "bpm"^^xsd:string ;
		lr:value "50"^^xsd:integer .
</pre>
						<p>G<sub>2, FHIR</sub> is:. </p>
						<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .


_:b4 a fhir:Observation ;
		obs:effectiveDateTime "2015-01-01T12:01:00Z"^^xsd:dateTimeStamp ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b5 .
	
_:b5 lr:unit "bpm"^^xsd:string ;
		lr:value "53"^^xsd:integer .
</pre>
						<p>G<sub>3, FHIR</sub> is: </p>
						<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b7 a fhir:Observation ;
		obs:effectiveDateTime "2015-01-01T12:02:00Z"^^xsd:dateTimeStamp ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b8 .
	
_:b8 lr:unit "bpm"^^xsd:string ;
		lr:value "48"^^xsd:integer .
</pre>
					</aside>
				</section>
				<aside class="example" id="ex-fhir-stream" title="FHIR Statements as RDF Stream">
					Recall that an <a>RDF Stream</a> is a sequence of <a>timestamped graphs</a>
					which are composed of a default graph and a named graph, where the default graph
					contains a distinguished triple called the timestamp triple. <p>We will
						construct an RDF Stream for the FHIR observation data, which as a whole is
						denoted S<sub>FHIR</sub>.</p>
					<p>Let G'<sub>1, FHIR</sub> be </p>
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b1 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b2 .
	
_:b2 lr:unit "bpm"^^xsd:string ;
		lr:value "50"^^xsd:integer .
</pre>
					<p>which is like G<sub>1, FHIR</sub> except it is missing the timestamp triple,
						and TS<sub>1, FHIR</sub> be the timestamp triple</p>
					<pre>
_:b1 obs:effectiveDateTime "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp
</pre>
					<p>We construct a timestamped graph with the constructor <a>TSGraph-NEW</a></p>
					<p>TSG<sub>1, FHIR</sub> = <a>TSGraph-NEW</a>(TS<sub>1, FHIR</sub>, G'<sub>1,
							FHIR</sub>)</p>
					<p>Similarly,</p>
					<p>TSG<sub>i, FHIR</sub> = TSGraph-NEW(TS<sub>i, FHIR</sub>, G'<sub>i,
							FHIR</sub>)</p>
					<p>The RDF stream can be abstractly constructed from its component timestamped
						graphs using basic operations:</p>
					<p>S<sub>FHIR</sub> = <a>Cons</a>(TSG<sub>3, FHIR</sub>, <a>Cons</a>(TSG<sub>2,
							FHIR</sub>, <a>Cons</a>(TSG<sub>1, FHIR</sub>, <a>SQ<sub>0</sub></a>))) </p>
					<p>where <a>SQ<sub>0</sub></a> is the null sequence.</p>
					<p>One possible way that this RDF Stream would be transmitted is as a sequence
						of RDF documents, each one containing an RDF graph corresponding to one
						element of the stream, where the timestamp triple is the first triple in the
						document. </p>
				</aside>
				<aside class="example" id="ex-fhir-tree" title="FHIR Statements as RDF Dataset"> The
					information about FHIR observations can also be represented using the <a>RDF
						Dataset</a> datatype. The named graph structure allows the statements of
					each stream element to be grouped together, and also allows us to materialize,
					in the default graph, statements giving the order among these elements. <p>Let
							D<sub>0, FHIR</sub> be</p>
					<pre>
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .

_:b102 prov:wasRevisionOf _:b101.
_:b103 prov:wasRevisionOf _:b102.
</pre>
					<p>We write</p>
					<p>D<sub>FHIR</sub> =
							<a>Tree-UNION</a>(<a>Tree-UNION</a>(<a>Tree-UNION</a>(D<sub>0,
							FHIR</sub>, D<sub>1, FHIR</sub>), D<sub>2, FHIR</sub>), D<sub>3,
							FHIR</sub>)</p>
					<p>where</p>
					<p>D<sub>i, FHIR</sub> = <a>Graph(</a>b<sub>i, FHIR</sub>, G<sub>i, FHIR</sub>)
						and</p>
					<p>b<sub>1, FHIR</sub>= _:b101, b<sub>2, FHIR</sub>= _:b102, b<sub>3,
						FHIR</sub>= _:b103 .</p>
					<p>The resulting associative tree D<sub>FHIR</sub> is as follows.</p>
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b102 prov:wasRevisionOf _:b101.
_:b103 prov:wasRevisionOf _:b102.
_:b101{
	    _:b1 a fhir:Observation ;
		    obs:code sct:36407505 ;
		    obs:device lr:sensor1234 ;
		    obs:effectiveDateTime "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp ;
		    obs:subject lr:patientA ;
		    obs:valueQuantity _:b2 .
	
	    _:b2 lr:unit "bpm"^^xsd:string ;
		    lr:value "50"^^xsd:integer .
}	

_:b102{
		_:b4 a fhir:Observation ;
			obs:code sct:36407505 ;
			obs:device lr:sensor1234 ;
			obs:effectiveDateTime "2015-01-01T12:01:00Z"^^xsd:dateTimeStamp ;
			obs:subject lr:patientA ;
			obs:valueQuantity _:b5 .
	
		_:b5 lr:unit "bpm"^^xsd:string ;
			lr:value "53"^^xsd:integer .
}
_:b103{
		_:b7 a fhir:Observation ;
			obs:code sct:36407505 ;
			obs:device lr:sensor1234 ;
			obs:effectiveDateTime "2015-01-01T12:02:00Z"^^xsd:dateTimeStamp ;
			obs:subject lr:patientA ;
			obs:valueQuantity _:b8 .
	
		_:b8 lr:unit "bpm"^^xsd:string ;
			lr:value "48"^^xsd:integer .
}
</pre>
				</aside>
				<aside class="example" id="ex-fhir-repository"
					title="FHIR Statements as a Repository"> The associative tree above is an
					associative data structure representing the entailment, under the provenance
					regime, of a first-order <a>Repository</a>. We denote this repository as
						R<sub>FHIR</sub>. In this example, the default part of the repository is
					empty. <p>We write</p>
					<p>R<sub>FHIR</sub> = [{}, [D<sub>i,FHIR</sub>]<sub>i=1, 2, 3</sub>]</p>
					<p>The repository can be abstractly constructed from its component associative
						trees using basic operations:</p>
					<p>R<sub>FHIR</sub> = <a>Revise</a>(D<sub>3,FHIR</sub>,
							<a>Revise</a>(D<sub>2,FHIR</sub>, <a>Revise</a>(D<sub>1,FHIR</sub>,
								<a>SQ<sub>0</sub></a>))) </p>
					<p> Since the sequential part of a repository may be lazily contructed, the
						repository could be transmitted as a sequence of documents, one for the
						associative part and one for each of the elements of the sequential part of
						the repository, transmitted as they become available. </p>
				</aside>
				<aside class="example" id="ex-fhir-repository"
					title="FHIR Statements as a Second-Order RDF Store">
					<p> The repository above has lost the information, contained in the stream, as
						to which is the timestamp triple of each timestamped graph. For this
						example, we can express that information as metadata for the entire
						repository, since it is sufficient to identify the timestamp predicate,
						because there is only one triple in the default graph of each timestamped
						graph that uses that predicate. Although this is a specialization of the RDF
						Stream structure, it would be the most common usecase. To attach this
						metadata to the repository as a whole, we name the repository and embed it
						in a second-order RDF Store. We denote this store as STR<sub>FHIR</sub>. </p>
					<p>We write</p>
					<p>STR<sub>FHIR</sub> = <a>Tree-UNION</a>(STR<sub>FHIR, associative</sub>,
							STR<sub>FHIR, sequential</sub>)</p>
					<p>where</p>
					<p>STR<sub>FHIR, associative</sub> =
						Associative-NEW<sub>2</sub>(G<sub>eff</sub>, {_:b301}, {_:b301 =>
							R<sub>FHIR</sub>})</p>
					<p>where G<sub>eff</sub> is the graph containing the single triple</p>
					<pre>
@prefix rsp: &lt;http://@@@#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .

_:b301 rsp:usesTimestampPredicate obs:effectiveDateTime.
				</pre>
					<p>The sequential part of the store STR can be abstractly constructed from its
						elements using basic operations:</p>
					<p>STR<sub>FHIR, sequential</sub> = <a>Cons</a>(STR<sub>3,FHIR</sub>,
							<a>Cons</a>(STR<sub>2,FHIR</sub>, <a>Cons</a>(STR<sub>1,FHIR</sub>,
								<a>SQ<sub>0</sub></a>))) </p>
					<p>where</p>
					<p> STR<sub>1, FHIR</sub> = [_:sv0, [_:b301, G<sub>1, FHIR</sub>, 1], 2]</p>
					<p> STR<sub>2, FHIR</sub> = [_:sv1, [_:b301, G<sub>2, FHIR</sub>, 1], 2]</p>
					<p> STR<sub>3, FHIR</sub> = [_:sv2, [_:b301, G<sub>3, FHIR</sub>, 1], 2]</p>
					<p>or generically</p>
					<p> STR<sub>i, FHIR</sub> = Associative-NEW<sub>2</sub>({}, {stver<sub>i</sub>},
							{stver<sub>i</sub> => Associative-NEW<sub>1</sub>({}, {_:b301}, {_:b301
						=> G<sub>i, FHIR</sub>})})</p>
					<p>where stver<sub>1</sub> = _:sv0, stver<sub>2</sub> = _:sv1, stver<sub>3</sub>
						= _:sv2.</p>
					<p>To construct a store in this fashion, it is necessary to ensure
						synchronization of the store and repository versions manually. A more
						reliable method is to use the store constructor
						<a>Store-NEW<sub>k</sub></a>.</p>
				</aside>
			</section>
			<section id="fhir-motion">
				<h3>Example of a Store Holding Two RDF Streams</h3>
				<aside class="example" id="ex-motion-graphs"
					title="FHIR Motion Observations as Graphs"> We model a second stream of FHIR
					observation data using the graphs below. <p>Let G<sub>1, FHIR-m</sub> be: </p>
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/> .
@prefix lr: &lt;http://localhost/local-records#> .
@prefix sct: &lt;http://snomed.info/id/> .
@prefix obs: &lt;http://hl7.org/fhir/Observation.> .
@prefix prov: &lt;http://www.w3.org/ns/prov#> .

	

_:m1 a fhir:Observation ;
		obs:code sct:251833007 ;
		obs:device lr:sensor5678 ;
		obs:effectiveDateTime "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:m2 .
	
_:m2 lr:unit "kJ"^^xsd:string ;
		lr:value "93"^^xsd:integer .
</pre>
					<p>Let G<sub>2, FHIR-m</sub> be: </p>
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/> .
@prefix lr: &lt;http://localhost/local-records#> .
@prefix sct: &lt;http://snomed.info/id/> .
@prefix obs: &lt;http://hl7.org/fhir/Observation.> .
@prefix prov: &lt;http://www.w3.org/ns/prov#> .

	

_:m4 a fhir:Observation ;
		obs:code sct:251833007 ;
		obs:device lr:sensor5678 ;
		obs:effectiveDateTime "2015-01-01T12:02:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:m5 .
	
_:m5 lr:unit "kJ"^^xsd:string ;
		lr:value "127"^^xsd:integer .
</pre>
					<p>Let G<sub>3, FHIR-m</sub> be: </p>
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/> .
@prefix lr: &lt;http://localhost/local-records#> .
@prefix sct: &lt;http://snomed.info/id/> .
@prefix obs: &lt;http://hl7.org/fhir/Observation.> .
@prefix prov: &lt;http://www.w3.org/ns/prov#> .

	

_:m7 a fhir:Observation ;
		obs:code sct:251833007 ;
		obs:device lr:sensor5678 ;
		obs:effectiveDateTime "2015-01-01T12:04:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:m8 .
	
_:m8 lr:unit "kJ"^^xsd:string ;
		lr:value "45"^^xsd:integer .
</pre>
				</aside>
				<aside class="example" id="ex-motion-trees"
					title="FHIR Motion Observations as Datasets">
					<p>Let</p>
					<p>D<sub>i, FHIR-m</sub> = <a>Graph(</a>b<sub>i, FHIR-m</sub>, G<sub>i,
							FHIR-m</sub>)</p>
					<p>where b<sub>1, FHIR-m</sub>= _:m0, b<sub>2, FHIR-m</sub>= _:m3, b<sub>3,
							FHIR-m</sub>= _:m6</p>
				</aside>
				<aside class="example" id="ex-motion-repository"
					title="FHIR Motion Observations as Repository">
					<p>Let</p>
					<p>R<sub>FHIR-m</sub> = [{}, [D<sub>i,FHIR-m</sub>]<sub>i=1, 2, 3</sub>]</p>
				</aside>
				<aside class="example" id="ex-graph-timestamp-pred-two"
					title="Metadata Stating Timestamp Predicate for Two Streams"><p> As in the
						previous example of a store holding an RDF Stream, we use the default
						repository of the store to hold the metadata regarding timestamp predicates.
						Let G<sub>eff, 2</sub> be the graph </p>
					<pre>
@prefix rsp: &lt;http://@@@#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .

_:rn1 rsp:usesTimestampPredicate obs:effectiveDateTime.
_:rn2 rsp:usesTimestampPredicate obs:effectiveDateTime.
				</pre>
				</aside>
				<aside class="example" id="ex-store-fhir-two"
					title="Store containing Two FHIR Streams">
					<p>We build a second-order store STR<sub>FHIR, 2</sub> from the first-order
						repositories R<sub>FHIR</sub> and R<sub>FHIR-m</sub> defined above. This is
						done using the Store-NEW<sub>2</sub> constructor. The arguments of the
							Store-NEW<sub>2</sub> constructor are as follows. </p>
					<ul>
						<li>The default first-order repository of the store, which in this case has
							default graph G<sub>eff, 2</sub> and no versions. .</li>
						<li>The set of repository names, {_:rn1, _:rn2}.</li>
						<li>The mapping from repository names to first-order repositories, {_:rn1 =>
								R<sub>FHIR</sub>, _:rn2 => R<sub>FHIR-m</sub>} </li>
						<li>The set of store version names {_:sv0, _:sv1, _:sv2, _:sv3}</li>
						<li>The partial functions from store version names onto repository version
							names. <ul>
								<li>The repository R<sub>FHIR</sub> (named _:rn1 in this store) has
									version names {_:b101, _:b102, _:b103}. For this repository, we
									assign to _:rn1 the mapping NM<sub>_:rn1</sub> = {_:sv0 =>
									_:b101, _:sv1 => _:b102, _:sv2 => _:b103}. Notice that the
									domain is a proper interval subset of the set of store version
									names.</li>
								<li>The repository R<sub>FHIR-m</sub> (named _:rn2 in this store)
									has version names {_:m101, _:m102, _:m103}. For this repository,
									we assign to _:rn2 the mapping NM<sub>_:rn2</sub> = {_:sv0 =>
									_:m101, _:sv1 => _:m101, _:sv2 => _:m102, _:sv3 => _:m103}.
									Notice that the domain of this mapping is the full set of store
									version names.</li>
							</ul>
						</li>
					</ul>
					<p>The mappings from store version names to repository version names are
						constructed so that the two streams are aligned within the store with regard
						to their timestamps. Since the two streams use the same timestamp predicate,
						this alignment sets up a query that creates a union of the two streams into
						one stream containing both FHIR observations, when available, using the same
						timestamp predicate.</p>
					<p>The store may also be continuously queried with matching performed against
						both streams without actually constructing an intermediate stream union. See
						the query example <a href="ex-store-query">Example !!!</a>.</p>
				</aside>
			</section>
			<section id="general-stream-example">
				<h3>General RDF Stream Example</h3>
				<aside class="example" id="ex-prov-tree" title="FHIR Provenance in an RDF Dataset">
					We consider a more general RDF Stream example, showing a typical case when sets
					of statements have multiple temporal characteristics. We construct a set of
					named graphs <p>NG<sub>i, FHIR</sub> = <a>Graph(</a>nb<sub>i</sub>, G<sub>i,
							FHIR</sub>)</p> where <p>nb<sub>1</sub> = _:b0, nb<sub>2</sub> = _:b3,
							nb<sub>3</sub> = _:b6 </p> and we express some provenance metadata using
					these graph names. Let G<sub>1, prov</sub> be
					<pre>
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .

_:b0 
	prov:generatedAtTime "2015-01-01T12:00:33Z"^^xsd:dateTime ;
    lr:stream lr:streamA12342015-01-01T12:00:00Z .
</pre>
					Let G<sub>2, prov</sub> be
					<pre>
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .

_:b3 
	prov:generatedAtTime "2015-01-01T12:01:45Z"^^xsd:dateTime ;
    lr:stream lr:streamA12342015-01-01T12:00:00Z .
</pre>
					Let G<sub>3, prov</sub> be
					<pre>
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .

_:b6 
	prov:generatedAtTime "2015-01-01T12:02:54Z"^^xsd:dateTime ;
    lr:stream lr:streamA12342015-01-01T12:00:00Z .
</pre>
					In this example, we have the time of observation as one temporal
					characteristics, and the time the observation report was generated as the second
					temporal characteristic, The entire associative tree is denoted D<sub>prov</sub>
					and is constructed as follows <p>D<sub>prov</sub> = <a>Tree-UNION</a>(
							<a>Tree-UNION</a>(D<sub>1,prov</sub>, D<sub>2,prov</sub>),
							D<sub>3,prov</sub> ) </p> where <p> D<sub>i,prov</sub> =
							<a>Tree-UNION</a>(G<sub>i, prov</sub>, NG<sub>i, FHIR</sub>) </p> The
					following is a representation of D<sub>prov</sub> in Trig. In this
					representation, the dytnamic aspects are implicitly expressed in timestamps, but
					the temporal order is not directly available through simple entailment.
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b0 
	prov:generatedAtTime "2015-01-01T12:00:33Z"^^xsd:dateTime ;
    lr:stream lr:streamA12342015-01-01T12:00:00Z .
_:b0 {
	_:b1 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:effectiveDateTime "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b2 .
	
	_:b2 lr:unit "bpm"^^xsd:string ;
		lr:value "50"^^xsd:integer .
}

_:b3 
	prov:generatedAtTime "2015-01-01T12:01:45Z"^^xsd:dateTime ;
    lr:stream lr:streamA12342015-01-01T12:00:00Z .
_:b3 {
	_:b4 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:effectiveDateTime "2015-01-01T12:01:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b5 .
	
	_:b5 lr:unit "bpm"^^xsd:string ;
		lr:value "53"^^xsd:integer .
}

_:b6 
	prov:generatedAtTime "2015-01-01T12:02:54Z"^^xsd:dateTime ;
    lr:stream lr:streamA12342015-01-01T12:00:00Z .
_:b6 {
	_:b7 a fhir:Observation ;
		obs:code sct:36407505 ;
		obs:device lr:sensor1234 ;
		obs:effectiveDateTime "2015-01-01T12:02:00Z"^^xsd:dateTimeStamp ;
		obs:subject lr:patientA ;
		obs:valueQuantity _:b8 .
	
	_:b8 lr:unit "bpm"^^xsd:string ;
		lr:value "48"^^xsd:integer .
}
</pre>
				</aside>
				<aside class="example" id="ex-prov-stream" title="FHIR Provenance in an RDF Stream">
					<p>The representation of this same information as an RDF Stream takes the form
						of the following sequence. The stream as a whole is denoted
						S<sub>prov</sub>. </p>
					<p>We write</p>
					<p>S<sub>prov</sub> = [TSG<sub>i,prov</sub>]<sub>i=1, 2, 3</sub></p>
					<p>A representation of the first element of the stream is a timestamped graph as
						follows.</p>
					<p>TSG<sub>i,prov</sub> = TSGraph-NEW(, D'<sub>i, prov</sub>)</p> where
						D'<sub>i, prov</sub> is like D<sub>i, prov</sub> except it is missing the
					timestamp triple. <p>D'<sub>i, prov</sub> = Tree-DIFF(D<sub>i, prov</sub>,
							TS<sub>i, prov</sub>) </p> where TS<sub>1, prov</sub> is <pre>
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .

_:b0 
	prov:generatedAtTime "2015-01-01T12:00:33Z"^^xsd:dateTime ;
</pre>
					<p>and so on.</p>
					<p>One possible way that this RDF Stream would be transmitted is as a sequence
						of RDF documents, each one containing an RDF Dataset corresponding to one
						element of the stream.</p>
					<p>In this example, each element of the stream contains a triple in its default
						graph that provides an identifier for the stream as a whole
							(<code>lr:streamA12342015-01-01T12:00:00Z</code>). This is optional for
						RDF streams.</p>
				</aside>
				<aside class="example" id="ex-prov-tree-2"
					title="FHIR Provenance in a Second-Order Dataset"> This data can also be
					represented using the second-order <a>associative tree</a> datatype. For this
					representation, we use an extension of the Trig syntax to "quints". This
					additional name allows the statements of each stream element to be grouped
					together, and also allows us to materialize, in the default (first-order)
					associative tree, statements giving the order among these elements. The
					second-order associative tree is denoted D2<sub>prov</sub>. <pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b202 prov:wasRevisionOf _:b201.
_:b203 prov:wasRevisionOf _:b202.

_:b201{
    DEFAULT {
		_:b0 
			prov:generatedAtTime "2015-01-01T12:00:33Z"^^xsd:dateTime ;
			lr:stream lr:streamA12342015-01-01T12:00:00Zm .
	}
    _:b0 {
	    _:b1 a fhir:Observation ;
		    obs:code sct:36407505 ;
		    obs:device lr:sensor1234 ;
		    obs:effectiveDateTime "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp ;
		    obs:subject lr:patientA ;
		    obs:valueQuantity _:b2 .
	
	    _:b2 lr:unit "bpm"^^xsd:string ;
		    lr:value "50"^^xsd:integer .
    }
}	

_:b202{
    DEFAULT {
		_:b3 
			prov:generatedAtTime "2015-01-01T12:01:45Z"^^xsd:dateTime ;
			lr:stream lr:streamA12342015-01-01T12:00:00Z .
	}
	_:b3 {
		_:b4 a fhir:Observation ;
			obs:code sct:36407505 ;
			obs:device lr:sensor1234 ;
			obs:effectiveDateTime "2015-01-01T12:01:00Z"^^xsd:dateTimeStamp ;
			obs:subject lr:patientA ;
			obs:valueQuantity _:b5 .
	
		_:b5 lr:unit "bpm"^^xsd:string ;
			lr:value "53"^^xsd:integer .
	}
}
_:b203{
    DEFAULT {
		_:b6 
			prov:generatedAtTime "2015-01-01T12:02:54Z"^^xsd:dateTime ;
			lr:stream lr:streamA12342015-01-01T12:00:00Z .
	}
	_:b6 {
		_:b7 a fhir:Observation ;
			obs:code sct:36407505 ;
			obs:device lr:sensor1234 ;
			obs:effectiveDateTime "2015-01-01T12:02:00Z"^^xsd:dateTimeStamp ;
			obs:subject lr:patientA ;
			obs:valueQuantity _:b8 .
	
		_:b8 lr:unit "bpm"^^xsd:string ;
			lr:value "48"^^xsd:integer .
	}
}
</pre>
					<p>We write</p>
					<p>D2<sub>prov</sub> = <a>Tree-UNION</a>( <a>Tree-UNION</a>( <a>Tree-UNION</a>(
							<a>Tree-UNION</a>(D<sub>0, prov</sub>,ND<sub>1, prov</sub>),ND<sub>2,
							prov</sub>),ND<sub>3, prov</sub>) </p>
					<p>where</p>
					<p>ND<sub>i, prov</sub> = <a>Dataset(</a> b<sub>i, prov</sub>, D<sub>i,
							prov</sub>)</p>
					<p>b<sub>1, prov</sub>= _:b201, b<sub>2, prov</sub>= _:b202, b<sub>3,
						prov</sub>= _:b203 .</p>
					<p>and</p>
					<p>D<sub>0, prov</sub> is</p>
					<pre>
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .

_:b202 prov:wasRevisionOf _:b201.
_:b203 prov:wasRevisionOf _:b202.
</pre>
				</aside>
				<aside class="example" id="ex-psrov-repository"
					title="FHIR Provenance as a Second-Order Repository">
					<p> The second-order associative tree above is an associative data structure
						representing the entailment, under the provenance regime, of a second-order
							<a>Repository</a>. The repository as a whole is denoted
						R<sub>prov</sub>. In this example, the default associative tree of the
						repository is empty. </p>
					<p>We write</p>
					<p>R<sub>prov</sub> = {} ∪ [ND<sub>i,prov</sub>]<sub>i=1, 2, 3</sub></p>
					<p> For this representation, we use the same extension of the Trig syntax to
						"quints" as in the previous example. Since repositories have sequential
						parts, one form of the transmission of the repository would be a sequence of
						documents representing named first-order associative trees, as shown below. </p>
					<p>The first document of the sequence is as follows. The named associative tree
						is denoted ND<sub>1, prov</sub>. </p>
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b201{
    DEFAULT {
		_:b0 
			prov:generatedAtTime "2015-01-01T12:00:33Z"^^xsd:dateTime ;
			lr:stream lr:streamA12342015-01-01T12:00:00Zm .
	}
    _:b0 {
	    _:b1 a fhir:Observation ;
		    obs:code sct:36407505 ;
		    obs:device lr:sensor1234 ;
		    obs:effectiveDateTime "2015-01-01T12:00:00Z"^^xsd:dateTimeStamp ;
		    obs:subject lr:patientA ;
		    obs:valueQuantity _:b2 .
	
	    _:b2 lr:unit "bpm"^^xsd:string ;
		    lr:value "50"^^xsd:integer .
    }
}	
</pre>
					<p>The second document of the sequence is as follows. The named associative tree
						is denoted ND<sub>2, prov</sub>. </p>
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b202{
    DEFAULT {
		_:b3 
			prov:generatedAtTime "2015-01-01T12:01:45Z"^^xsd:dateTime ;
			lr:stream lr:streamA12342015-01-01T12:00:00Z .
	}
	_:b3 {
		_:b4 a fhir:Observation ;
			obs:code sct:36407505 ;
			obs:device lr:sensor1234 ;
			obs:effectiveDateTime "2015-01-01T12:01:00Z"^^xsd:dateTimeStamp ;
			obs:subject lr:patientA ;
			obs:valueQuantity _:b5 .
	
		_:b5 lr:unit "bpm"^^xsd:string ;
			lr:value "53"^^xsd:integer .
	}
}
</pre>
					<p>The third document of the sequence is as follows. The named associative tree
						is denoted ND<sub>3, prov</sub>. </p>
					<pre>
@prefix fhir: &lt;http://hl7.org/fhir/&gt; .
@prefix lr: &lt;http://localhost/local-records#&gt; .
@prefix obs: &lt;http://hl7.org/fhir/Observation.&gt; .
@prefix prov: &lt;http://www.w3.org/ns/prov#&gt; .
@prefix sct: &lt;http://snomed.info/id/&gt; .

_:b203{
    DEFAULT {
		_:b6 
			prov:generatedAtTime "2015-01-01T12:02:54Z"^^xsd:dateTime ;
			lr:stream lr:streamA12342015-01-01T12:00:00Z .
	}
	_:b6 {
		_:b7 a fhir:Observation ;
			obs:code sct:36407505 ;
			obs:device lr:sensor1234 ;
			obs:effectiveDateTime "2015-01-01T12:02:00Z"^^xsd:dateTimeStamp ;
			obs:subject lr:patientA ;
			obs:valueQuantity _:b8 .
	
		_:b8 lr:unit "bpm"^^xsd:string ;
			lr:value "48"^^xsd:integer .
	}
}
</pre>
				</aside>
			</section>
			<section id="pattern-examples">
				<h3>Pattern Examples</h3>
				<aside class="example" id="ex-bgp-fhir-heartrate"
					title="Basic Graph Pattern for FHIR Heartrate Observation">
					<p>The basic graph pattern (BGP) below will be used to demonstrate how solution
						mappings might be extracted from the above data structures. This BGP is
						denoted TP<sub>FHIR-heartrate</sub>. </p>
					<pre>
?heartRateObservation a fhir:Observation ;
          obs:subject ?patient ;
          obs:effectiveDateTime ?heartRate_time ;
          obs:code &lt;http://snomed.info/sct:36407505&gt; ; # heart rate
          obs:valueQuantity [ fhir:Quantity.value ?heartRate;
                              fhir:Quantity.unit 'bpm'        ] .
</pre>
				</aside>
				<aside class="example" id="ex-bgp-pattern-prov-revise"
					title="Basic Graph Pattern for Revision Statements">
					<p>The basic graph pattern (BGP) below will be used to demonstrate how solution
						mappings about the relative order of versions of a repository might be
						extracted from the above data structures using the provenance entailment
						regime. This BGP is denoted TP<sub>revise</sub>. </p>
					<pre>
?version prov:wasRevisionOf ?previous.
</pre>
				</aside>
				<aside class="example" id="ex-bgp-pattern-prov-initial"
					title="Basic Graph Pattern for Initial Version Statements">
					<p>The basic graph pattern (BGP) below will be used to demonstrate how solution
						mappings describing the initial version of a repository might be extracted
						from the above data structures using the provenance entailment regime. This
						BGP is denoted TP<sub>initialVersion</sub>. </p>
					<pre>
?version repo:isInitialVersion "true"^^xsd:boolean .
</pre>
				</aside>
				<aside class="example" id="ex-bgp-pattern-prov-initial-of"
					title="Basic Graph Pattern for Initial Version Statements for Named Repositories">
					<p>The basic graph pattern (BGP) below will be used to demonstrate how solution
						mappings describing the initial version of a named repository might be
						extracted from the above data structures using the provenance entailment
						regime. This BGP is denoted TP<sub>initialVersionOf</sub>. </p>
					<pre>
?version repo:isInitialVersionOf ?repo .
</pre>
				</aside>
				<aside class="example" id="ex-bgp-pattern-prov-terminal"
					title="Basic Graph Pattern for Terminal Version Statements">
					<p>The basic graph pattern (BGP) below will be used to demonstrate how solution
						mappings describing the terminal version of a repository might be extracted
						from the above data structures using the repository structure entailment
						regime. This BGP is denoted TP<sub>terminalVersion</sub>. </p>
					<pre>
?version repo:isTerminalVersion "true"^^xsd:boolean .
</pre>
				</aside>
				<aside class="example" id="ex-bgp-pattern-prov-terminal-of"
					title="Basic Graph Pattern for Terminal Version Statements for Named Repositories">
					<p>The basic graph pattern (BGP) below will be used to demonstrate how solution
						mappings describing the terminal version of a named repository might be
						extracted from the above data structures using the repository structure
						entailment regime. This BGP is denoted TP<sub>terminalVersionOf</sub>. </p>
					<pre>
?version repo:isTerminalVersionOf ?repo .
</pre>
				</aside>
				<aside class="example" id="ex-quad-fhir-heartrate"
					title="QuadPattern for FHIR Heartrate Observation">
					<p>The <a>Quadpattern</a> below will be used to demonstrate how solution
						mappings might be extracted from the above data structures. This
							<a>Quadpattern</a> is denoted QP<sub>FHIR-heartrate</sub>. </p>
					<pre>
GRAPH ?g {
	?heartRateObservation a fhir:Observation ;
          obs:subject ?patient ;
          obs:effectiveDateTime ?heartRate_time ;
          obs:code &lt;http://snomed.info/sct:36407505&gt; ; # heart rate
          obs:valueQuantity [ fhir:Quantity.value ?heartRate;
                              fhir:Quantity.unit 'bpm'        ] .
}
</pre>
					<p>We write</p>
					<p>QP<sub>FHIR-heartrate</sub> = <a>Graph(</a> ?g, TP<sub>FHIR-heartrate</sub>)
					</p>
				</aside>
				<aside class="example" id="ex-id-pattern-0"
					title="Identity Pattern for Zeroth Order"> This BGP is denoted IDP<sub>0</sub>.
					<pre>
{?s ?p ?o.}
</pre> The abstract algebra expression is <p> IDP<sub>0</sub>
						= BGP(?s ?p ?o) </p>
				</aside>
				<aside class="example" id="ex-id-pattern-1" title="Identity Pattern for First Order"
					> This GraphPattern is denoted IDP<sub>1</sub>.
					<pre>
{ graph ?g {?s ?p ?o} } union {?s ?p ?o}
</pre> The abstract algebra
					expression is <p> IDP<sub>1</sub> = <a>Union</a>( <a>Graph(</a> ?g,
							IDP<sub>0</sub> ), IDP<sub>0</sub>) </p>
				</aside>
				<aside class="example" id="ex-id-pattern-2"
					title="Identity Pattern for Second Order"> This DatasetPattern is denoted
						IDP<sub>2</sub>.
					<pre>
	{ @@@dataset ?d { { graph ?g {?s ?p ?o} } union {?s ?p ?o} } }    
	 union
	{ graph ?g {?s ?p ?o} } union {?s ?p ?o}
</pre>
					The abstract algebra expression is <p> IDP<sub>2</sub> = <a>Union</a>(
							<a>Dataset(</a> ?d, IDP<sub>1</sub> ), IDP<sub>1</sub>) </p> and in
					general <p> IDP<sub>k+1</sub> = <a>Union</a>( <a>Dataset(</a> ?d,
							IDP<sub>k</sub> ), IDP<sub>k</sub>) </p>
				</aside>
			</section>
			<section id="query-examples">
				<h3>Query Examples</h3>
				<aside class="example" id="ex-select-triple-pattern-avg-hr"
					title="Select Query with Triple Pattern for Average Heartrate">
					<pre>
	
SELECT (AVG(?heartRate) AS ?heartRate_base)

WHERE {
        ?heartRateObservation a fhir:Observation ;
          obs:subject ?patient ;
          obs:effectiveDateTime ?heartRate_time ;
          obs:code &lt;http://snomed.info/sct:36407505&gt; ; # heart rate
          obs:valueQuantity [ fhir:Quantity.value ?heartRate;
                              fhir:Quantity.unit 'bpm'        ] .
        FILTER ( ?heartRate_time &gt;= (now() - 'P30D'^^xsd:dayTimeDuration) )
    }
</pre>
				</aside>
			</section>
			<section id="abstract-algebra-examples">
				<h3>Abstract Algebra Examples</h3>
				<section id="eval-examples">
					<h4>Eval</h4>
					<aside class="example" id="ex-match-bgp-tree"
						title="Matching a BGP Against a k-th Order Dataset">
						<p>If k=0, then application of eval to a associative tree and BGP
							corresponds to matching a BGP against an RDF Graph.</p>
						<p>If k=1, then application of eval to a associative tree and BGP
							corresponds to matching a BGP against an RDF Dataset, so that the
							default graph is active.</p>
						<p>If k=2, then application of eval to a associative tree and BGP
							corresponds to matching a BGP against the RDF Dataset that is the
							default associative tree of the second-order associative tree. For
							example,</p>
						<p>
							<a>eval</a>(<a href="#prov-tree-2">D2<sub>prov</sub></a>, <a
								href="#bgp-pattern-prov-revise">TP<sub>rev</sub></a>) =
								Ω<sub>rev</sub>
						</p>
						<p> where Ω<sub>rev</sub> is shown in the following table:</p>
						<table id="omega-rev">
							<tr>
								<th>?version</th>
								<th>?previous</th>
							</tr>
							<tr>
								<td>_:b202</td>
								<td>_:b201</td>
							</tr>
							<tr>
								<td>_:b203</td>
								<td>_:b202</td>
							</tr>
						</table>
					</aside>
					<aside class="example" id="ex-match-bgp-repository"
						title="Matching a BGP Against a k-th Order Repository">
						<p>If k=0, then application of eval to a repository and BGP corresponds to
							matching the BGP against an RDF Graph, as defined in [[!SPARQL11-Query]]
							.</p>
						<p>If k=1, then application of eval to a repository and BGP corresponds to
							matching the BGP against the RDF Graph that is the associative part of
							the first-order repository.</p>
						<p>For example,</p>
						<p>
							<a>eval</a>(<a href="#prov-tree-2">D2<sub>prov</sub></a>, <a
								href="#bgp-pattern-prov-revise">TP<sub>rev</sub></a>) = <a
								href="#omega-rev">Ω<sub>rev</sub></a>
						</p>
						<p>If k=2, then application of eval to a repository and BGP corresponds to
							matching the BGP against the RDF Dataset that is the associative part of
							the second-order repository.</p>
						<p>In general, application of eval to a (k+1)-th repository and BGP
							corresponds to matching the BGP against the k-th order RDF Dataset that
							is the associative part of the input repository. The result is a
							multiset of solution mappings.</p>
					</aside>
					<aside class="example" id="ex-match-quad-tree"
						title="Matching a QuadPattern Against a k-th Order Dataset">
						<p>Recall that a <a>QuadPattern</a>, also called a GraphGraphPattern, can
							match within named and unnamed graphs, depending on the nature of the
							pattern.</p>
						<p>If k=0, then application of eval to a associative tree and QuadPattern
							corresponds to matching a QuadPattern against an RDF Graph, as defined
							in [[!SPARQL11-Query]].</p>
						<p>If k=1, then application of eval to a associative tree and QuadPattern
							corresponds to matching a QuadPattern against an RDF Dataset, also as
							defined in [[!SPARQL11-Query]]. Such an operation can extract
							information from both the default and named components of the
							associative tree. </p>
						<p>If k>=2, then application of eval to a associative tree and QuadPattern
							corresponds to matching the QuadPattern against the default (k-1)-th
							order RDF Dataset of the input associative tree, which may be defined by
							induction over the order. As shown in the next example, a second-order
							pattern (containing "quint" patterns) is needed to access the
							information in the (non-default) named components of a second-order
							associative tree. </p>
					</aside>
					<aside class="example" id="ex-match-quint-second-order-tree"
						title="Matching a Second-Order Pattern Against a Second-Order Dataset">
						<p>
							<a>eval</a>(<a href="#prov-tree-2">D2<sub>prov</sub></a>, <a
								href="#id-pattern-2">IDP<sub>2</sub></a>) = Ω<sub>D2-prov</sub>
						</p>
						<p> where Ω<sub>D2-prov</sub> is partially shown in the following table:</p>
						<table id="omega-d2-prov">
							<tr>
								<th>?s</th>
								<th>?p</th>
								<th>?o</th>
								<th>?g</th>
								<th>?d</th>
							</tr>
							<tr>
								<td>_:b202</td>
								<td>prov:wasRevisionOf</td>
								<td>_:b201</td>
								<td></td>
								<td></td>
							</tr>
							<tr>
								<td>_:b0</td>
								<td>prov:generatedAtTime</td>
								<td>"2015-01-01T12:00:33Z"^^xsd:dateTime</td>
								<td></td>
								<td>_:b201</td>
							</tr>
							<tr>
								<td>_:b1</td>
								<td>rdf:type</td>
								<td>fhir:Observation</td>
								<td>_:b0</td>
								<td>_:b201</td>
							</tr>
						</table>
					</aside>
					<aside class="example" id="ex-match-quad-first-order-repository"
						title="Matching a First-Order Pattern Against a First-Order Repository">
						<p>Recall the definition of the FHIR repository, which has an empty default
							part.</p>
						<p>R<sub>FHIR</sub> = [{}, [D<sub>i,FHIR</sub>]<sub>i=1, 2, 3</sub>]</p>
						<p>If we apply the first-order identity pattern IDP<sub>1</sub> to this
							repository, we obtain the following result structure.</p>
						<p>
							<a>eval</a>(<a href="#fhir-repository">R<sub>FHIR</sub></a>, <a
								href="#id-pattern-1">IDP<sub>1</sub></a>) = [{} , [Ω<sub>i,
								R-FHIR</sub>]<sub>i=1,2,3</sub>] </p>
						<p> where Ω<sub>i, R-FHIR</sub> = <a>eval</a>( D<sub>i, FHIR</sub>,
								IDP<sub>1</sub>) </p>
						<!--is partially shown in the following table:</p>
		<table id="omega-d2-prov">
			<tr>
				<th>?s</th>
				<th>?p</th>
				<th>?o</th>
				<th>?g</th>
				<th>?d</th>
			</tr>
			<tr>
				<td>_:b202</td>
				<td>prov:wasRevisionOf</td>
				<td>_:b201</td>
				<td></td>
				<td></td>
			</tr>
			<tr>
				<td>_:b0</td>
				<td>prov:generatedAtTime</td>
				<td>"2015-01-01T12:00:33Z"^^xsd:dateTime</td>
				<td></td>
				<td>_:b201</td>
			</tr>
			<tr>
				<td>_:b1</td>
				<td>rdf:type</td>
				<td>fhir:Observation</td>
				<td>_:b0</td>
				<td>_:b201</td>
			</tr>
		</table>-->
					</aside>
					<!--
	 The Eval function has been extended to apply to higher-order associative trees, repositories and stores.
     If the pattern is a BGP, then matching will be performed only within the default part 
	 (associative tree, repository or store, as the case may be.)
	 <p>The multiset of solution mappings that is obtained by applying the BGP 
	 <a href='#bgp-pattern-prov-revise'>TP<sub>rev</sub></a> to the second-order associative tree <a href='#prov-tree-2'>D2<sub>prov</sub></a> is
	 shown in the following table, and is denoted Ω<sub>rev</sub>.
	 </p>
	 Application of the same BGP to the second-order <a>repository</a> <a href="#fhir-repository">R<sub>prov</sub></a>
	 under the simple entailment regime
	 results in an empty set of solution mappings.
	 <p>Eval(R<sub>prov</sub>, TP<sub>rev</sub>) = {}</p>
	 However, the solutions above are obtained under the provenance entailment regime
	 <p>Eval-Prov(R<sub>prov</sub>, TP<sub>rev</sub>) = Ω<sub>rev</sub></p>
	</aside>
	<p class="ednote">OK, the extension of the eval function has not actually been defined yet.</p>
     <aside class="example" id="ex-match-quad-pattern" title="Matching a QuadPattern">
     If the pattern is a quad pattern, then matching will be performed according to two cases.
	 <ul>
	   <li>If the data structure  (associative tree, repository, or store) is of first-order, then the quad pattern
	   will be applied to named components.
	   </li>
	   <li>If the data structure  (associative tree, repository, or store) is of order higher than first, 
	   then the quad pattern will be applied to the default component.
	   </li>
	 </ul>
	 <p>The solutions that are obtained by applying the QuadPattern 
	 <a href='#quad-fhir-heartrate'>QP<sub>FHIR-heartrate</sub></a> to 
	 the first-order associative tree <a href='#fhir-tree'>D<sub>FHIR</sub></a> are
	 shown in the following table, and denoted by Ω<sub>hr</sub>.
	 </p>
	 <table>
		<tr>
			<th>?g</th>
			<th>?heartRateObservation</th>
			<th>?patient</th>
			<th>?heartRate_time</th>
			<th>?heartRate</th>
		</tr>
		<tr>
			<td>_:b101</td>
			<td>_:b1</td>
			<td>lr:patientA</td>
			<td>"2015-01-01T12:00:00Z"^^xsd:dateTimeStamp</td>
			<td>50"^^xsd:integer</td>
		</tr>
		<tr>
			<td>_:b102</td>
			<td>_:b4</td>
			<td>lr:patientA</td>
			<td>"2015-01-01T12:01:00Z"^^xsd:dateTimeStamp</td>
			<td>53"^^xsd:integer</td>
		</tr>
		<tr>
			<td>_:b103</td>
			<td>_:b7</td>
			<td>lr:patientA</td>
			<td>"2015-01-01T12:02:00Z"^^xsd:dateTimeStamp</td>
			<td>48"^^xsd:integer</td>
		</tr>
		
	 </table>
We write
	 <p>Eval(D<sub>FHIR</sub>, QP<sub>FHIR-heartrate</sub>) = Ω<sub>hr</sub></p>

	 When the same QuadPattern is applied to the first-order <a>repository</a> <a href="#fhir-repository">R<sub>FHIR</sub></a>
	 we also obtain the solutions above.
	 This is because the eval function corresponds to simple entailment,
	 and simple entailment on a repository is defined as simple entailment
	 on the associative tree obtained by forgetting the sequential order of versions.
	 <p>Eval(R<sub>FHIR</sub>, QP<sub>FHIR-heartrate</sub>) = Ω<sub>hr</sub></p>
	</aside>
	</section>
	<section id="ceval-examples">
	<h4>Ceval</h4>
	<p>
     A new function (Ceval) has also been defined for performing repeated (also called "continuous") matching
	 of patterns against data structures with sequential parts.
	 Continuous matching is "push-style" when the transmission is streamed;
	 a match event is triggered by the arrival of a stream element.
	 </p>
	<aside class="example" id="ex-continuous-match-bgp" title="Continuous Matching with a BGP">
	</aside>
	 <p  class="ednote">To be moved to the section where Ceval is defined:
	 Continuous matching is applicable to
	  <a>Repositories</a>, <a>Stores</a>,
	   sequences of <a>k-th order associative trees</a>,
	   and <a>k-th Order Sequential RDF Datasets</a>, 
	   which are structures consisting of a sequence of <a>k-th order associative trees</a>
	   and a distinguished <a>k-th order associative trees</a> called the default associative tree.
     </p>
	 <p class="ednote">To define the semantics of Ceval, we need a new datatype for the result, called
	 <dfn>Structured Result</dfn>, consisting of a distinguished multiset of solution mappings, possibly empty, 
	 the default component of the structured result, and a
	 totally-ordered set of solutions (possibly empty, finite or infinite), the sequential component of the structured result.
	 </p>
	 <p class="ednote">
	 In the case that the first argument is a <a>Repository</a>, <a>Store</a>,
	 the Ceval function takes a pattern as second argument.
	 </p>
	 <p class="ednote">
	 The pattern is matched to the default component of the input data structure, 
	 to generate the default component of the <a>structured result</a>.
	 </p>
	 <p class="ednote">
	 The pattern is also matched against the union of an element of the sequence
	 together with the default component,
	 to generate the sequential part of the <a>structured result</a>.
     </p>
	 <p>The solution sequence that is obtained by matching the QuadPattern 
	 <a href='#quad-fhir-heartrate'>QP<sub>FHIR-heartrate</sub></a> continuously to 
	 the first-order repository <a href="#fhir-repository">R<sub>FHIR</sub></a> is
	 shown in the following sequence of tables, denoted by [Ω<sub>i, hr</sub>]<sub>i = 1, 2, 3</sub>.
	 </p>
	 <table>
		<tr>
			<th>?g</th>
			<th>?heartRateObservation</th>
			<th>?patient</th>
			<th>?heartRate_time</th>
			<th>?heartRate</th>
		</tr>
		<tr>
			<td>_:b101</td>
			<td>_:b1</td>
			<td>lr:patientA</td>
			<td>"2015-01-01T12:00:00Z"^^xsd:dateTimeStamp</td>
			<td>50"^^xsd:integer</td>
		</tr>
	 </table>
	 <br/><br/>
	 <table>
		<tr>
			<th>?g</th>
			<th>?heartRateObservation</th>
			<th>?patient</th>
			<th>?heartRate_time</th>
			<th>?heartRate</th>
		</tr>
		<tr>
			<td>_:b102</td>
			<td>_:b4</td>
			<td>lr:patientA</td>
			<td>"2015-01-01T12:01:00Z"^^xsd:dateTimeStamp</td>
			<td>53"^^xsd:integer</td>
		</tr>
	 </table>
	 <br/><br/>
		<table>
		<tr>
			<th>?g</th>
			<th>?heartRateObservation</th>
			<th>?patient</th>
			<th>?heartRate_time</th>
			<th>?heartRate</th>
		</tr>
		<tr>
			<td>_:b103</td>
			<td>_:b7</td>
			<td>lr:patientA</td>
			<td>"2015-01-01T12:02:00Z"^^xsd:dateTimeStamp</td>
			<td>48"^^xsd:integer</td>
		</tr>
		
	 </table>
	 <p>The Quadpattern QP<sub>FHIR-heartrate</sub> will yield no solutions
	 when matched to an RDF graph. Therefore the default component of the result is empty, no matter what
	 is in the default part R<sub>FHIR</sub>.
	 </p>
	 <p>We write</p>
	 <p>Ceval(R<sub>FHIR</sub>, QP<sub>FHIR-heartrate</sub>) = {} ∪ [Ω<sub>i,hr</sub>]<sub>i=1, 2, 3</sub></p>
	 as well as
	 <p>Ceval-prov(R<sub>FHIR</sub>, QP<sub>FHIR-heartrate</sub>) = {} ∪ [Ω<sub>i,hr</sub>]<sub>i=1, 2, 3</sub></p>
	 <p class="ednote">RDF Stream remarks:
	 Recall that inference on an RDF stream is supposed to be oblivious to which triple is the timestamp triple.
	 The special status of timestamp triple is supposed to only be used in windowing operations. 
	 So, a continuous query on a stream should not be able to determine which triple is the timestamp triple.
	 However, a second-order repository that emulates an RDF stream needs to keep this information somewhere,
	 for windowing purposes.
	 The default part of the repository is the logical place for this information to be stored. 
	 With a property "repo:hasTimestampTriple", and the RDF reification vocabulary, this
	 information can be materialized provided there is an identifier for each stream element (and this
	 identifier is an inherent part of the second-order repository).
	 Queries of the repository that are supposed to emulate queries of the stream MUST not access that information.
	 This works out OK as long as a repository is used to emulate the stream - the pattern to match against stream elements
	 must have a second-order name (i.e. it is a quint pattern) and so will give no solutions when matched against the
	 default first-order associative tree.
	 </p>
	 <p class="ednote">Restrictions on the arguments of Ceval in order to emulate an unwindowed query of an RDF stream:
	 </p>
	 <ol>
	 <li>It is necessary to include the (second-order) associative tree name as a variable in the query, so that 
	     the query matching is scoped to one stream element at a time. However, there needs to be a
		 Projection applied to the solution so that the associative tree name is forgotten for the <a>structured result</a>
	 </li>
	 <li>Since an RDF Stream does not have a default part, there should be no additional entailments
	     such as those arising from the structural information of the stream, with property <code>repo:hasTimestampTriple</code>.
		 On the other hand, we want to enable queries of RDF streams jointly with associative data structures.
		 The union of a associative and sequential data structure puts the associative statements into the default part of the
		 sequential part, so the union of a associative data structure and an RDF stream will have a default component (except for the trivial
		 case when the associative part is empty). For proper querying in this case, it would be helpful if in the "union" the
		 elements of sequential components are named with blank nodes, so that the result of the union is a repository.
		 On the other hand, the union of a stream with an empty associative data structure causes a change of type, which is undesirable.
	</li>	 
	 </ol>
	 <p class="ednote">
	 	 Note that windowing is supposed to be performed prior to pattern matching, so if windowing is done on an RDF stream,
	 the result is a stream (sequence) of RDF Datasets, and this is not (in general) an RDF Stream.
	 So we also need to define Ceval on a sequence of (unnamed) RDF Datasets, and further, show how to
	 restrict the arguments of Ceval so that a second-order repository can be used to emulate a stream of RDF Datasets.
	 </p>
	<p class="ednote">
	 In the case that the first argument of Ceval is a <a>sequential data structure</a>,
	 the Ceval function takes a <a>k-th Order Pattern</a>, P<sub>seq</sub>, as second argument,
	 and an optional <a>k-th Order Pattern</a>, P<sub>def</sub> as third argument.
	 The pattern P<sub>seq</sub> is matched continuously against
	 the union of each element of the sequence with the default part,
	 to generate the sequential part of the <a>structured result</a>,
	 while the default component of the <a>structured result</a> is obtained
	 from a one-time match of P<sub>def</sub> against the default part.
	 </p>
	 <p class="ednote">
	 The case that the first argument is an <a>RDF Stream</a>
     is a specialization of the case that the first argument is a sequence of 
	 <a>k-th Order RDF associative trees</a>, with k = 1, with empty default part.
	 Therefore, the second argument P<sub>seq</sub> MUST be a Quadpattern.
	 If a third argument is present, it has no effect since the default part is empty.
	 </p>
	 <p class="ednote">
	 The case that the first argument is the merger or union of an <a>RDF Stream</a>
	 with a first-order associative tree
     is also a specialization of the case that the first argument is a sequence of 
	 <a>k-th order associative trees</a>, with k = 1, with non-empty default part.
	 Again, the second argument P<sub>seq</sub> MUST be a Quadpattern.
	 If a third argument is present, it does have an effect since the default part is non-empty.
	 </p>
	 <p class="ednote">This formulation of the Ceval function that takes two pattern arguments is
	 not very satisfactory because it breaks the SPARQL syntactic convention of processing just one pattern at a time.
	 It might be better to split off the matching of the pattern on the default structure to another
	 Eval spinoff, e.g. Seval - for Associative evaluation on a sequential data structure, where the pattern is matched
	 only against the default component, and the result is a single multiset of solution mappings.
	 </p>
	<p class="ednote">OK, the continuous eval function Ceval has not actually been defined yet either.
	The description above will form the basis of that definition.
	The problem is that we have proposed three different "evals" on sequential data structures, Eval, Ceval and Seval.
	To express this in the concrete syntax, we need to provide a hint as to which "eval" function is intended,
	given
	</p>
	<pre>
	SELECT *
	FROM &lt;sequential data structure IRI&gt;
	WHERE {some pattern}
	</pre>
	<p>
	There is a choice for indicating the different kinds of eval syntactically (with reserved words) or semantically,
	with e.g. query strings.
	In the former case, the syntactic hints can be applied to construct subqueries without binding them to an IRI.
	In the latter case, IRIs become non-opaque, since the query string would be used to determine the transformation
	from concrete to abstract syntax.
	</p>
	-->
				</section>
				<section id="tree-union-examples">
					<h4>Tree-UNION</h4>
					<p>The Tree-UNION basic operation has been extended to apply to arbitrary pairs
						of higher-order associative trees. It has also been extended to apply to
						pairs where one of the elements is a higher-order associative tree and the
						other is a sequential data structure (repository, store, data sequence ). </p>
					<p> In all cases, the first step of evaluation is to elevate an associative
						input argument as needed: to the same order (in the case of two higher-order
						associative trees), or in the case of one associative and one sequential
						data structure, to the requisite orders so that the default component of the
						sequential data structure is of the same order as the associative part. Then
						it is sufficient to consider input arguments where these orders are already
						compatible. The type of the result is either a sequential data structure, of
						the same type and order as the sequential input, or an associative,
						higher-order associative tree, of the order of the two inputs. </p>
				</section>
			</section>
		</section>
		<section id="structural-inferences">
			<div style="text-align: left;">
				<table class="thinborder" style="margin-left: auto; margin-right: auto;">
					<caption id="structural-inferences-table"><b>Table D</b>: Inferences under the
						provenance and structural entailment regimes</caption>
					<tbody>
						<tr>
							<th><b>Structure</b></th>
							<th><b>Regime</b></th>
							<th><b>Property</b></th>
							<th><b>Usage</b>
							</th>
						</tr>
						<tr>
							<td><a>Repository</a>
								<a>Store</a></td>
							<td>provenance</td>
							<td>prov:wasRevisionOf</td>
							<td>Usage </td>
						</tr>
						<tr>
							<td><a>Repository</a>
								<a>Store</a>
							</td>
							<td>provenance</td>
							<td>repo:isInitialVersion</td>
							<td>Usage </td>
						</tr>
						<tr>
							<td><a>Repository</a>
								<a>Store</a>
							</td>
							<td>structural</td>
							<td>repo:isTerminalVersion</td>
							<td>Usage </td>
						</tr>
						<tr>
							<td><a>Store</a>
							</td>
							<td>provenance</td>
							<td>prov:isSpecializationOf</td>
							<td>Usage </td>
						</tr>
						<tr>
							<td><a>Store</a>
							</td>
							<td>provenance</td>
							<td>repo:isInitialVersionOf</td>
							<td>Usage </td>
						</tr>
						<tr>
							<td><a>Store</a>
							</td>
							<td>structural</td>
							<td>repo:isTerminalVersionOf</td>
							<td>Usage </td>
						</tr>
					</tbody>
				</table>
			</div>
		</section>
		<section id="sec-meta-variables">
			<h4>Metavariable Conventions</h4>
			<div data-include="metavariable-datatype.html" data-include-replace="true"
				data-include-sync="true"></div>
		</section>
		<section id="sec-reserved-names">
			<h4>Reserved Names</h4>
			<div>
				<table>
					<thead>
						<tr>
							<td>Name</td>
							<td>Purpose</td>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td><a>DEFAULT</a></td>
							<td>Explicit indication that a triple is in the default graph of an RDF
								Dataset. Similarly, indicates that a substructure is in the default
								part of a higher-order associative structures.</td>
						</tr>
						<tr>
							<td>ASSOC</td>
							<td>Explicit indication that a substructure is in the <a>associative
									part</a> of a <a>multivalent structure</a>. </td>
						</tr>
						<tr>
							<td>NIL</td>
							<td>Reserved version name used for the empty greatest version of a
								repository or store that is permanently "cleared", e.g. a repository
								in a store that has been "dropped". Other version names can be used
								for empty versions, but these versions may be revised. The operation
									<a>Append2Repository</a> applied to a repository whose greatest
								version name is <a>NIL</a> is undefined.</td>
						</tr>
					</tbody>
				</table>
			</div>
		</section>
		<section>
			<h3>Summary of Datatypes</h3>
			<p>The following table summarizes datatypes. The rows using "::=" provide a definition
				of the datatype as a composition. The rows using "::&lt;" provide a compositional
				supertype of that datatype.</p>
			<table style="font: monospace;">
				<thead data-include="table-head-datatype.html" data-include-sync="true"></thead>
				<tbody>
					<tr>
						<td><dfn>Nat</dfn></td>
						<td>::=</td>
						<td>set of Natural Numbers</td>
					</tr>
					<tr>
						<td><dfn>Z<sup>*</sup></dfn></td>
						<td>::=</td>
						<td>non-negative integers</td>
					</tr>
					<tr>
						<td>2<sup>X</sup></td>
						<td>::=</td>
						<td>set of subsets of X</td>
					</tr>
					<tr>
						<td>X<sup>*</sup></td>
						<td>::=</td>
						<td>finite sequences of X, including the empty sequence</td>
					</tr>
					<tr>
						<td>X<sup>+</sup></td>
						<td>::=</td>
						<td>non-empty finite sequences of X</td>
					</tr>
					<tr>
						<td><dfn>℘</dfn>(X)</td>
						<td>::=</td>
						<td>set of all permutations of X</td>
					</tr>
					<tr>
						<td><dfn>℘℘</dfn>(X)</td>
						<td>::=</td>
						<td>set of all partial permutations of X, i.e. set of all totally-ordered
							subsets of X</td>
					</tr>
					<tr>
						<td><dfn>1</dfn></td>
						<td>::=</td>
						<td>{{}}</td>
					</tr>
					<tr>
						<td><dfn>Partial</dfn>:X=>Y</td>
						<td>::=</td>
						<td>partial functions from X to Y</td>
					</tr>
				</tbody>
				<tbody data-include="associative-datatype.html" data-include-sync="true"></tbody>
				<tbody data-include="solitary-association-datatype.html" data-include-sync="true"></tbody>
				<tbody>
					<tr>
						<td>associative-tree<sub>0</sub></td>
						<td>::=</td>
						<td>RDF Graph</td>
					</tr>
					<tr>
						<td>associative-tree<sub>k</sub>, k &gt; 0</td>
						<td>::=</td>
						<td>TypeAssoc<sub>k</sub>(associative-tree<sub>&le; k-1</sub>)</td>
					</tr>
					<tr>
						<td><dfn>associative-tree<sub>&le; k</sub></dfn>, k &ge; 0</td>
						<td>::=</td>
						<td>&cup;<sub>i &le; k</sub>
							<a>associative-tree</a><sub>i</sub></td>
					</tr>
				</tbody>
				<tbody data-include="sequence-datatype.html" data-include-sync="true"></tbody>
				<tbody data-include="structure-datatype.html" data-include-sync="true"></tbody>

				<tbody>
					<tr>
						<td><dfn>TypeVer<sub>k</sub></dfn>(X, Y), k &gt; 0</td>
						<td>::&lt;</td>
						<td>[<a>Nat</a>, <a>℘℘</a>(<a>RDF Name</a>), <a>Partial</a>:(<a>RDF Name</a>
							=> Y &cup; {<a>ASSOC</a>} => X)]</td>
					</tr>
					<tr>
						<td></td>
						<td>::=</td>
						<td>{<a>Versioned-NEW<sub>k</sub></a>(NI, DSTM) | NI &in; <a>℘℘</a>(<a>RDF
								Name</a>), DSTM: NI|<sub>Y</sub> &cup; {<a>ASSOC</a>} => X) where
							DSTM(x) = DSTM(y), x &lt; y &in; NI implies there is some z &in; NI, x
							&lt; z &lt; y}</td>
					</tr>
					<tr>
						<td><dfn data-lt="versioned">versioned<sub>k</sub></dfn>, k &ge; 1</td>
						<td>::=</td>
						<td><a>TypeVer<sub>k</sub></a>(<a>structure<sub>&le; k</sub></a>,
								structure<sub>&le; k-1</sub>)</td>
					</tr>
				</tbody>
				<tbody>
					<tr>
						<td><a>solitary-association-tree<sub>k</sub></a>, k &gt; 0</td>
						<td>::=</td>
						<td><a>solitary-association<sub>k</sub></a> &cap;
									<a>associative-tree<sub>k</sub></a></td>
					</tr>
				</tbody>
				<tbody>
					<tr>
						<td><dfn>repository<sub>k</sub></dfn>, k &ge; 1</td>
						<td>::&lt;</td>
						<td> associative-tree<sub>&le; k-1</sub> x
									<a>TypeSeq<sup>+</sup></a>(<a>solitary-association-tree<sub>k</sub></a>)
						</td>
					</tr>
					<tr>
						<td></td>
						<td>::=</td>
						<td><a>TypeVer<sub>k</sub></a>(associative-tree<sub>&le; k-1</sub>,
								associative-tree<sub>&le; k-1</sub>)</td>
					</tr>
				</tbody>
				<tbody>
					<tr>
						<td><dfn>store<sub>k</sub></dfn>, k &ge; 2</td>
						<td>::&lt;</td>
						<td> (<a>TypeAssoc<sub>k</sub></a>(repository<sub>k-1</sub>) x
									<a>TypeSeq<sup>+</sup></a>(<a>solitary-association-tree<sub>k</sub></a>)
							)</td>
					</tr>
					<tr>
						<td></td>
						<td>::&lt;</td>
						<td><a>TypeVer<sub>k</sub></a>(<a>TypeAssoc<sub>k</sub></a>(repository<sub>k-1</sub>),
								associative-tree<sub>k-1</sub>)</td>
					</tr>
					<tr>
						<td></td>
						<td>::=</td>
						<td>{<a>Store-NEW<sub>k</sub></a>(RN, RM, SI, NM) | RN &in; 2<sup>RDF
								Name</sup> - 1, RM: RN<sub>ext</sub> => repository<sub>k-1</sub>,
							@@@plus other requirement on SI and NM as given in the definition of
									<a>Store-NEW<sub>k</sub></a>}</td>
					</tr>
				</tbody>
				<!-- Not done yet
						<tr>
							<td>stream<sub>i</sub></td>
							<td>::=</td>
							<td>?</td>
						</tr>
						-->
			</table>
		</section>
		<section id="sec-operator-syntax-summary">
			<h4>Summary of Operator Syntax</h4>
			<div>
				<table>
					<thead data-include="table-head-syntax.html" data-include-sync="true"></thead>
					<tbody data-include="associative-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="solitary-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="sequence-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="structure-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="tree-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="versioned-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="repository-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="store-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="stream-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
					<tbody data-include="operator-syntax.html" data-include-replace="true"
						data-include-sync="true"></tbody>
				</table>
			</div>
		</section>
		<!-- CONFORMANCE -->
		<section id="conformance"> </section>
	</body>
</html>
